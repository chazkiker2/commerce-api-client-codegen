/* tslint:disable */
/* eslint-disable */
/**
 * Commerce API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from './base';
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoAccountSnapshotDTOPaymentMethodTypeEnum;
(function (FoolCommerceDtoAccountSnapshotDTOPaymentMethodTypeEnum) {
    FoolCommerceDtoAccountSnapshotDTOPaymentMethodTypeEnum["CreditCard"] = "CreditCard";
    FoolCommerceDtoAccountSnapshotDTOPaymentMethodTypeEnum["ElectronicCheck"] = "ElectronicCheck";
    FoolCommerceDtoAccountSnapshotDTOPaymentMethodTypeEnum["ApplePay"] = "ApplePay";
    FoolCommerceDtoAccountSnapshotDTOPaymentMethodTypeEnum["Any"] = "Any";
})(FoolCommerceDtoAccountSnapshotDTOPaymentMethodTypeEnum || (FoolCommerceDtoAccountSnapshotDTOPaymentMethodTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoBillingActivityDTOAccountActionEnum;
(function (FoolCommerceDtoBillingActivityDTOAccountActionEnum) {
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["CardAdded"] = "CardAdded";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["CardUpdated"] = "CardUpdated";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["CardDeleted"] = "CardDeleted";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["BillingAddressAdded"] = "BillingAddressAdded";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["BillingAddressUpdated"] = "BillingAddressUpdated";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["BillingAddressDeleted"] = "BillingAddressDeleted";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["AccountChargeSucceeded"] = "AccountChargeSucceeded";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["AccountChargeFailed"] = "AccountChargeFailed";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["AccountRefundSucceeded"] = "AccountRefundSucceeded";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["AccountRefundFailure"] = "AccountRefundFailure";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["SubscriptionExpired"] = "SubscriptionExpired";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["SubscriptionRenewed"] = "SubscriptionRenewed";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["SubscriptionPutInGrace"] = "SubscriptionPutInGrace";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["SubscriptionCancelled"] = "SubscriptionCancelled";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["RenewalNoticeSent"] = "RenewalNoticeSent";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["VoidSucceeded"] = "VoidSucceeded";
    FoolCommerceDtoBillingActivityDTOAccountActionEnum["VoidFailed"] = "VoidFailed";
})(FoolCommerceDtoBillingActivityDTOAccountActionEnum || (FoolCommerceDtoBillingActivityDTOAccountActionEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoCreatePromotionFormAudienceTypeEnum;
(function (FoolCommerceDtoCreatePromotionFormAudienceTypeEnum) {
    FoolCommerceDtoCreatePromotionFormAudienceTypeEnum["NewMember"] = "NewMember";
    FoolCommerceDtoCreatePromotionFormAudienceTypeEnum["Retention"] = "Retention";
    FoolCommerceDtoCreatePromotionFormAudienceTypeEnum["Acquisition"] = "Acquisition";
})(FoolCommerceDtoCreatePromotionFormAudienceTypeEnum || (FoolCommerceDtoCreatePromotionFormAudienceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoCreditCardPaymentMethodTypeEnum;
(function (FoolCommerceDtoCreditCardPaymentMethodTypeEnum) {
    FoolCommerceDtoCreditCardPaymentMethodTypeEnum["CreditCard"] = "CreditCard";
    FoolCommerceDtoCreditCardPaymentMethodTypeEnum["ElectronicCheck"] = "ElectronicCheck";
    FoolCommerceDtoCreditCardPaymentMethodTypeEnum["ApplePay"] = "ApplePay";
    FoolCommerceDtoCreditCardPaymentMethodTypeEnum["Any"] = "Any";
})(FoolCommerceDtoCreditCardPaymentMethodTypeEnum || (FoolCommerceDtoCreditCardPaymentMethodTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoElectronicCheckFormAccountTypeEnum;
(function (FoolCommerceDtoElectronicCheckFormAccountTypeEnum) {
    FoolCommerceDtoElectronicCheckFormAccountTypeEnum["Checking"] = "Checking";
    FoolCommerceDtoElectronicCheckFormAccountTypeEnum["Savings"] = "Savings";
})(FoolCommerceDtoElectronicCheckFormAccountTypeEnum || (FoolCommerceDtoElectronicCheckFormAccountTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoMemberActionsMemberSubscriptionActionFormActionEnum;
(function (FoolCommerceDtoMemberActionsMemberSubscriptionActionFormActionEnum) {
    FoolCommerceDtoMemberActionsMemberSubscriptionActionFormActionEnum["TurnOffAutoRenewal"] = "TurnOffAutoRenewal";
    FoolCommerceDtoMemberActionsMemberSubscriptionActionFormActionEnum["CancelSubscription"] = "CancelSubscription";
    FoolCommerceDtoMemberActionsMemberSubscriptionActionFormActionEnum["SwapServices"] = "SwapServices";
    FoolCommerceDtoMemberActionsMemberSubscriptionActionFormActionEnum["EnableAutoRenewal"] = "EnableAutoRenewal";
})(FoolCommerceDtoMemberActionsMemberSubscriptionActionFormActionEnum || (FoolCommerceDtoMemberActionsMemberSubscriptionActionFormActionEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoOrderStatusEnum;
(function (FoolCommerceDtoOrderStatusEnum) {
    FoolCommerceDtoOrderStatusEnum["Pending"] = "Pending";
    FoolCommerceDtoOrderStatusEnum["Completed"] = "Completed";
    FoolCommerceDtoOrderStatusEnum["AuthorizationFailure"] = "AuthorizationFailure";
    FoolCommerceDtoOrderStatusEnum["AuthorizationError"] = "AuthorizationError";
})(FoolCommerceDtoOrderStatusEnum || (FoolCommerceDtoOrderStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoPaymentMethodPaymentMethodTypeEnum;
(function (FoolCommerceDtoPaymentMethodPaymentMethodTypeEnum) {
    FoolCommerceDtoPaymentMethodPaymentMethodTypeEnum["CreditCard"] = "CreditCard";
    FoolCommerceDtoPaymentMethodPaymentMethodTypeEnum["ElectronicCheck"] = "ElectronicCheck";
    FoolCommerceDtoPaymentMethodPaymentMethodTypeEnum["ApplePay"] = "ApplePay";
    FoolCommerceDtoPaymentMethodPaymentMethodTypeEnum["Any"] = "Any";
})(FoolCommerceDtoPaymentMethodPaymentMethodTypeEnum || (FoolCommerceDtoPaymentMethodPaymentMethodTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoPromotionAudienceTypeEnum;
(function (FoolCommerceDtoPromotionAudienceTypeEnum) {
    FoolCommerceDtoPromotionAudienceTypeEnum["NewMember"] = "NewMember";
    FoolCommerceDtoPromotionAudienceTypeEnum["Retention"] = "Retention";
    FoolCommerceDtoPromotionAudienceTypeEnum["Acquisition"] = "Acquisition";
})(FoolCommerceDtoPromotionAudienceTypeEnum || (FoolCommerceDtoPromotionAudienceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoSolrOfferDocumentAudienceTypeEnum;
(function (FoolCommerceDtoSolrOfferDocumentAudienceTypeEnum) {
    FoolCommerceDtoSolrOfferDocumentAudienceTypeEnum["NewMember"] = "NewMember";
    FoolCommerceDtoSolrOfferDocumentAudienceTypeEnum["Retention"] = "Retention";
    FoolCommerceDtoSolrOfferDocumentAudienceTypeEnum["Acquisition"] = "Acquisition";
})(FoolCommerceDtoSolrOfferDocumentAudienceTypeEnum || (FoolCommerceDtoSolrOfferDocumentAudienceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoSubscriptionProductLevelEnum;
(function (FoolCommerceDtoSubscriptionProductLevelEnum) {
    FoolCommerceDtoSubscriptionProductLevelEnum["LevelOne"] = "LevelOne";
    FoolCommerceDtoSubscriptionProductLevelEnum["LevelTwo"] = "LevelTwo";
    FoolCommerceDtoSubscriptionProductLevelEnum["LevelThree"] = "LevelThree";
    FoolCommerceDtoSubscriptionProductLevelEnum["LevelFour"] = "LevelFour";
    FoolCommerceDtoSubscriptionProductLevelEnum["LevelFive"] = "LevelFive";
})(FoolCommerceDtoSubscriptionProductLevelEnum || (FoolCommerceDtoSubscriptionProductLevelEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum;
(function (FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum) {
    FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum["LevelOne"] = "LevelOne";
    FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum["LevelTwo"] = "LevelTwo";
    FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum["LevelThree"] = "LevelThree";
    FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum["LevelFour"] = "LevelFour";
    FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum["LevelFive"] = "LevelFive";
})(FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum || (FoolCommerceDtoSubscriptionProductDescriptionProductLevelEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoUpdatePromotionFormAudienceTypeEnum;
(function (FoolCommerceDtoUpdatePromotionFormAudienceTypeEnum) {
    FoolCommerceDtoUpdatePromotionFormAudienceTypeEnum["NewMember"] = "NewMember";
    FoolCommerceDtoUpdatePromotionFormAudienceTypeEnum["Retention"] = "Retention";
    FoolCommerceDtoUpdatePromotionFormAudienceTypeEnum["Acquisition"] = "Acquisition";
})(FoolCommerceDtoUpdatePromotionFormAudienceTypeEnum || (FoolCommerceDtoUpdatePromotionFormAudienceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum;
(function (FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum) {
    FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum["LevelOne"] = "LevelOne";
    FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum["LevelTwo"] = "LevelTwo";
    FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum["LevelThree"] = "LevelThree";
    FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum["LevelFour"] = "LevelFour";
    FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum["LevelFive"] = "LevelFive";
})(FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum || (FoolCommerceDtoUpdateSubscriptionProductLevelFormProductLevelEnum = {}));
/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Set default billing address by UID
         * @param {number} uid
         * @param {FoolCommerceDtoPostalAddressForm} [foolCommerceDtoPostalAddressForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateBillingAddress: async (uid, foolCommerceDtoPostalAddressForm, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('addOrUpdateBillingAddress', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/billing-address`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoPostalAddressForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set default phone number by UID
         * @param {number} uid
         * @param {string} [phoneNumber]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateBillingPhoneNumber: async (uid, phoneNumber, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('addOrUpdateBillingPhoneNumber', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/billing-phone-number`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (uid, countryCode, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getAccount', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns details of SourceCode / IP Address / NumberOfOrders highlighted as potential fraud risk for this specific user within the specified date range.  Note: Potential fraud risk is defined as attempting orders with at least 3 different payment methods within a specified number of hours.
         * @param {number} uid
         * @param {string} startDate Data type is DATE, not DATETIME.
         * @param {string} endDate Data type is DATE, not DATETIME.
         * @param {number} [minPaymentMethods] Must be &gt;&#x3D; 3.
         * @param {number} [subsequentPaymentMinutes] Must be less than 1440 (one day).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountFraudRiskOrderDetails: async (uid, startDate, endDate, minPaymentMethods, subsequentPaymentMinutes, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getAccountFraudRiskOrderDetails', 'uid', uid);
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getAccountFraudRiskOrderDetails', 'startDate', startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getAccountFraudRiskOrderDetails', 'endDate', endDate);
            const localVarPath = `/v1/accounts/{uid}/fraud-risk-details`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate instanceof Date) ?
                    startDate.toISOString() :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate instanceof Date) ?
                    endDate.toISOString() :
                    endDate;
            }
            if (minPaymentMethods !== undefined) {
                localVarQueryParameter['minPaymentMethods'] = minPaymentMethods;
            }
            if (subsequentPaymentMinutes !== undefined) {
                localVarQueryParameter['subsequentPaymentMinutes'] = subsequentPaymentMinutes;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPurchaseLockout: async (uid, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getCurrentUserPurchaseLockout', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/purchase-lockout`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Product Entitlements By UID
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductEntitlementsForUser: async (uid, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getProductEntitlementsForUser', 'uid', uid);
            const localVarPath = `/v1/accounts/product-entitlements/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get products owned by given UID
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsOwnedByUid: async (uid, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getProductsOwnedByUid', 'uid', uid);
            const localVarPath = `/v1/accounts/product-owned-by-uid/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account reports by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {'Free' | 'Paid' | 'Any'} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports: async (uid, countryCode, type, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getReports', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/reports`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account subscriptions by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {'Active' | 'Expired' | 'Any'} [status]
         * @param {number} [productId]
         * @param {boolean} [allowDiscontinuedProducts]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: async (uid, countryCode, status, productId, allowDiscontinuedProducts, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSubscriptions', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/subscriptions`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (allowDiscontinuedProducts !== undefined) {
                localVarQueryParameter['allowDiscontinuedProducts'] = allowDiscontinuedProducts;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns list of user\'s payment processor transactions either created by Commerce db or imported on the reconciliation report
         * @param {number} uid
         * @param {boolean} [existsInCommerceDb] null &#x3D; either/True &#x3D; exists in Commerce/False &#x3D; does not exist in Commerce db
         * @param {boolean} [existsInPaymentProvider] null &#x3D; either/True &#x3D; exists in audit import/False &#x3D; does not exist in audit import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPaymentProcessorTransactionDetails: async (uid, existsInCommerceDb, existsInPaymentProvider, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getUserPaymentProcessorTransactionDetails', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/transaction-details`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (existsInCommerceDb !== undefined) {
                localVarQueryParameter['existsInCommerceDb'] = existsInCommerceDb;
            }
            if (existsInPaymentProvider !== undefined) {
                localVarQueryParameter['existsInPaymentProvider'] = existsInPaymentProvider;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uid
         * @param {number} [subscriptionId]
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscriptionBillingActivity: async (uid, subscriptionId, page, pageSize, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getUserSubscriptionBillingActivity', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/billing-activity`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uid
         * @param {FoolCommerceDtoLockUserPurchasesForm} [foolCommerceDtoLockUserPurchasesForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUserPurchases: async (uid, foolCommerceDtoLockUserPurchasesForm, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('lockUserPurchases', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/purchase-lockout/lock`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoLockUserPurchasesForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uid
         * @param {number} subscriptionId
         * @param {FoolCommerceDtoMemberActionsMemberSubscriptionActionForm} [foolCommerceDtoMemberActionsMemberSubscriptionActionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAccountSubscriptionAction: async (uid, subscriptionId, foolCommerceDtoMemberActionsMemberSubscriptionActionForm, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('requestAccountSubscriptionAction', 'uid', uid);
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('requestAccountSubscriptionAction', 'subscriptionId', subscriptionId);
            const localVarPath = `/v1/accounts/{uid}/subscriptions/{subscriptionId}/action`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoMemberActionsMemberSubscriptionActionForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set specific payment method to user\'s default payment method
         * @param {number} uid The UID of the user,
         * @param {number} paymentMethodId The ID of the desired Payment Method to set as user\&#39;s default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodForUser: async (uid, paymentMethodId, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setDefaultPaymentMethodForUser', 'uid', uid);
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('setDefaultPaymentMethodForUser', 'paymentMethodId', paymentMethodId);
            const localVarPath = `/v1/accounts/{uid}/payment-methods/{paymentMethodId}/make-default`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Should send Create Password email
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shouldSendCreatePasswordEmail: async (email, options = {}) => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('shouldSendCreatePasswordEmail', 'email', email);
            const localVarPath = `/v1/accounts/{email}/should-send-create-password-email`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uid
         * @param {FoolCommerceDtoUnlockUserPurchasesForm} [foolCommerceDtoUnlockUserPurchasesForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUserPurchases: async (uid, foolCommerceDtoUnlockUserPurchasesForm, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('unlockUserPurchases', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/purchase-lockout/unlock`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoUnlockUserPurchasesForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Set default billing address by UID
         * @param {number} uid
         * @param {FoolCommerceDtoPostalAddressForm} [foolCommerceDtoPostalAddressForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrUpdateBillingAddress(uid, foolCommerceDtoPostalAddressForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrUpdateBillingAddress(uid, foolCommerceDtoPostalAddressForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Set default phone number by UID
         * @param {number} uid
         * @param {string} [phoneNumber]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrUpdateBillingPhoneNumber(uid, phoneNumber, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrUpdateBillingPhoneNumber(uid, phoneNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get account by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(uid, countryCode, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(uid, countryCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns details of SourceCode / IP Address / NumberOfOrders highlighted as potential fraud risk for this specific user within the specified date range.  Note: Potential fraud risk is defined as attempting orders with at least 3 different payment methods within a specified number of hours.
         * @param {number} uid
         * @param {string} startDate Data type is DATE, not DATETIME.
         * @param {string} endDate Data type is DATE, not DATETIME.
         * @param {number} [minPaymentMethods] Must be &gt;&#x3D; 3.
         * @param {number} [subsequentPaymentMinutes] Must be less than 1440 (one day).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountFraudRiskOrderDetails(uid, startDate, endDate, minPaymentMethods, subsequentPaymentMinutes, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountFraudRiskOrderDetails(uid, startDate, endDate, minPaymentMethods, subsequentPaymentMinutes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserPurchaseLockout(uid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserPurchaseLockout(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Product Entitlements By UID
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductEntitlementsForUser(uid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductEntitlementsForUser(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get products owned by given UID
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsOwnedByUid(uid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsOwnedByUid(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get account reports by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {'Free' | 'Paid' | 'Any'} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReports(uid, countryCode, type, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReports(uid, countryCode, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get account subscriptions by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {'Active' | 'Expired' | 'Any'} [status]
         * @param {number} [productId]
         * @param {boolean} [allowDiscontinuedProducts]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptions(uid, countryCode, status, productId, allowDiscontinuedProducts, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptions(uid, countryCode, status, productId, allowDiscontinuedProducts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns list of user\'s payment processor transactions either created by Commerce db or imported on the reconciliation report
         * @param {number} uid
         * @param {boolean} [existsInCommerceDb] null &#x3D; either/True &#x3D; exists in Commerce/False &#x3D; does not exist in Commerce db
         * @param {boolean} [existsInPaymentProvider] null &#x3D; either/True &#x3D; exists in audit import/False &#x3D; does not exist in audit import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPaymentProcessorTransactionDetails(uid, existsInCommerceDb, existsInPaymentProvider, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPaymentProcessorTransactionDetails(uid, existsInCommerceDb, existsInPaymentProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uid
         * @param {number} [subscriptionId]
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSubscriptionBillingActivity(uid, subscriptionId, page, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSubscriptionBillingActivity(uid, subscriptionId, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uid
         * @param {FoolCommerceDtoLockUserPurchasesForm} [foolCommerceDtoLockUserPurchasesForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockUserPurchases(uid, foolCommerceDtoLockUserPurchasesForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockUserPurchases(uid, foolCommerceDtoLockUserPurchasesForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uid
         * @param {number} subscriptionId
         * @param {FoolCommerceDtoMemberActionsMemberSubscriptionActionForm} [foolCommerceDtoMemberActionsMemberSubscriptionActionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestAccountSubscriptionAction(uid, subscriptionId, foolCommerceDtoMemberActionsMemberSubscriptionActionForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestAccountSubscriptionAction(uid, subscriptionId, foolCommerceDtoMemberActionsMemberSubscriptionActionForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Set specific payment method to user\'s default payment method
         * @param {number} uid The UID of the user,
         * @param {number} paymentMethodId The ID of the desired Payment Method to set as user\&#39;s default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethodForUser(uid, paymentMethodId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethodForUser(uid, paymentMethodId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Should send Create Password email
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shouldSendCreatePasswordEmail(email, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shouldSendCreatePasswordEmail(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uid
         * @param {FoolCommerceDtoUnlockUserPurchasesForm} [foolCommerceDtoUnlockUserPurchasesForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockUserPurchases(uid, foolCommerceDtoUnlockUserPurchasesForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockUserPurchases(uid, foolCommerceDtoUnlockUserPurchasesForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AccountApiFp(configuration);
    return {
        /**
         *
         * @summary Set default billing address by UID
         * @param {number} uid
         * @param {FoolCommerceDtoPostalAddressForm} [foolCommerceDtoPostalAddressForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateBillingAddress(uid, foolCommerceDtoPostalAddressForm, options) {
            return localVarFp.addOrUpdateBillingAddress(uid, foolCommerceDtoPostalAddressForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set default phone number by UID
         * @param {number} uid
         * @param {string} [phoneNumber]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateBillingPhoneNumber(uid, phoneNumber, options) {
            return localVarFp.addOrUpdateBillingPhoneNumber(uid, phoneNumber, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get account by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(uid, countryCode, options) {
            return localVarFp.getAccount(uid, countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns details of SourceCode / IP Address / NumberOfOrders highlighted as potential fraud risk for this specific user within the specified date range.  Note: Potential fraud risk is defined as attempting orders with at least 3 different payment methods within a specified number of hours.
         * @param {number} uid
         * @param {string} startDate Data type is DATE, not DATETIME.
         * @param {string} endDate Data type is DATE, not DATETIME.
         * @param {number} [minPaymentMethods] Must be &gt;&#x3D; 3.
         * @param {number} [subsequentPaymentMinutes] Must be less than 1440 (one day).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountFraudRiskOrderDetails(uid, startDate, endDate, minPaymentMethods, subsequentPaymentMinutes, options) {
            return localVarFp.getAccountFraudRiskOrderDetails(uid, startDate, endDate, minPaymentMethods, subsequentPaymentMinutes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPurchaseLockout(uid, options) {
            return localVarFp.getCurrentUserPurchaseLockout(uid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Product Entitlements By UID
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductEntitlementsForUser(uid, options) {
            return localVarFp.getProductEntitlementsForUser(uid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get products owned by given UID
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsOwnedByUid(uid, options) {
            return localVarFp.getProductsOwnedByUid(uid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get account reports by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {'Free' | 'Paid' | 'Any'} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(uid, countryCode, type, options) {
            return localVarFp.getReports(uid, countryCode, type, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get account subscriptions by its UID
         * @param {number} uid
         * @param {string} [countryCode]
         * @param {'Active' | 'Expired' | 'Any'} [status]
         * @param {number} [productId]
         * @param {boolean} [allowDiscontinuedProducts]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(uid, countryCode, status, productId, allowDiscontinuedProducts, options) {
            return localVarFp.getSubscriptions(uid, countryCode, status, productId, allowDiscontinuedProducts, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns list of user\'s payment processor transactions either created by Commerce db or imported on the reconciliation report
         * @param {number} uid
         * @param {boolean} [existsInCommerceDb] null &#x3D; either/True &#x3D; exists in Commerce/False &#x3D; does not exist in Commerce db
         * @param {boolean} [existsInPaymentProvider] null &#x3D; either/True &#x3D; exists in audit import/False &#x3D; does not exist in audit import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPaymentProcessorTransactionDetails(uid, existsInCommerceDb, existsInPaymentProvider, options) {
            return localVarFp.getUserPaymentProcessorTransactionDetails(uid, existsInCommerceDb, existsInPaymentProvider, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uid
         * @param {number} [subscriptionId]
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscriptionBillingActivity(uid, subscriptionId, page, pageSize, options) {
            return localVarFp.getUserSubscriptionBillingActivity(uid, subscriptionId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uid
         * @param {FoolCommerceDtoLockUserPurchasesForm} [foolCommerceDtoLockUserPurchasesForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUserPurchases(uid, foolCommerceDtoLockUserPurchasesForm, options) {
            return localVarFp.lockUserPurchases(uid, foolCommerceDtoLockUserPurchasesForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uid
         * @param {number} subscriptionId
         * @param {FoolCommerceDtoMemberActionsMemberSubscriptionActionForm} [foolCommerceDtoMemberActionsMemberSubscriptionActionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAccountSubscriptionAction(uid, subscriptionId, foolCommerceDtoMemberActionsMemberSubscriptionActionForm, options) {
            return localVarFp.requestAccountSubscriptionAction(uid, subscriptionId, foolCommerceDtoMemberActionsMemberSubscriptionActionForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set specific payment method to user\'s default payment method
         * @param {number} uid The UID of the user,
         * @param {number} paymentMethodId The ID of the desired Payment Method to set as user\&#39;s default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodForUser(uid, paymentMethodId, options) {
            return localVarFp.setDefaultPaymentMethodForUser(uid, paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Should send Create Password email
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shouldSendCreatePasswordEmail(email, options) {
            return localVarFp.shouldSendCreatePasswordEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uid
         * @param {FoolCommerceDtoUnlockUserPurchasesForm} [foolCommerceDtoUnlockUserPurchasesForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUserPurchases(uid, foolCommerceDtoUnlockUserPurchasesForm, options) {
            return localVarFp.unlockUserPurchases(uid, foolCommerceDtoUnlockUserPurchasesForm, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     *
     * @summary Set default billing address by UID
     * @param {number} uid
     * @param {FoolCommerceDtoPostalAddressForm} [foolCommerceDtoPostalAddressForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    addOrUpdateBillingAddress(uid, foolCommerceDtoPostalAddressForm, options) {
        return AccountApiFp(this.configuration).addOrUpdateBillingAddress(uid, foolCommerceDtoPostalAddressForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set default phone number by UID
     * @param {number} uid
     * @param {string} [phoneNumber]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    addOrUpdateBillingPhoneNumber(uid, phoneNumber, options) {
        return AccountApiFp(this.configuration).addOrUpdateBillingPhoneNumber(uid, phoneNumber, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get account by its UID
     * @param {number} uid
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccount(uid, countryCode, options) {
        return AccountApiFp(this.configuration).getAccount(uid, countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns details of SourceCode / IP Address / NumberOfOrders highlighted as potential fraud risk for this specific user within the specified date range.  Note: Potential fraud risk is defined as attempting orders with at least 3 different payment methods within a specified number of hours.
     * @param {number} uid
     * @param {string} startDate Data type is DATE, not DATETIME.
     * @param {string} endDate Data type is DATE, not DATETIME.
     * @param {number} [minPaymentMethods] Must be &gt;&#x3D; 3.
     * @param {number} [subsequentPaymentMinutes] Must be less than 1440 (one day).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountFraudRiskOrderDetails(uid, startDate, endDate, minPaymentMethods, subsequentPaymentMinutes, options) {
        return AccountApiFp(this.configuration).getAccountFraudRiskOrderDetails(uid, startDate, endDate, minPaymentMethods, subsequentPaymentMinutes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getCurrentUserPurchaseLockout(uid, options) {
        return AccountApiFp(this.configuration).getCurrentUserPurchaseLockout(uid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Product Entitlements By UID
     * @param {number} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getProductEntitlementsForUser(uid, options) {
        return AccountApiFp(this.configuration).getProductEntitlementsForUser(uid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get products owned by given UID
     * @param {number} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getProductsOwnedByUid(uid, options) {
        return AccountApiFp(this.configuration).getProductsOwnedByUid(uid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get account reports by its UID
     * @param {number} uid
     * @param {string} [countryCode]
     * @param {'Free' | 'Paid' | 'Any'} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getReports(uid, countryCode, type, options) {
        return AccountApiFp(this.configuration).getReports(uid, countryCode, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get account subscriptions by its UID
     * @param {number} uid
     * @param {string} [countryCode]
     * @param {'Active' | 'Expired' | 'Any'} [status]
     * @param {number} [productId]
     * @param {boolean} [allowDiscontinuedProducts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getSubscriptions(uid, countryCode, status, productId, allowDiscontinuedProducts, options) {
        return AccountApiFp(this.configuration).getSubscriptions(uid, countryCode, status, productId, allowDiscontinuedProducts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns list of user\'s payment processor transactions either created by Commerce db or imported on the reconciliation report
     * @param {number} uid
     * @param {boolean} [existsInCommerceDb] null &#x3D; either/True &#x3D; exists in Commerce/False &#x3D; does not exist in Commerce db
     * @param {boolean} [existsInPaymentProvider] null &#x3D; either/True &#x3D; exists in audit import/False &#x3D; does not exist in audit import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getUserPaymentProcessorTransactionDetails(uid, existsInCommerceDb, existsInPaymentProvider, options) {
        return AccountApiFp(this.configuration).getUserPaymentProcessorTransactionDetails(uid, existsInCommerceDb, existsInPaymentProvider, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} uid
     * @param {number} [subscriptionId]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getUserSubscriptionBillingActivity(uid, subscriptionId, page, pageSize, options) {
        return AccountApiFp(this.configuration).getUserSubscriptionBillingActivity(uid, subscriptionId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} uid
     * @param {FoolCommerceDtoLockUserPurchasesForm} [foolCommerceDtoLockUserPurchasesForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    lockUserPurchases(uid, foolCommerceDtoLockUserPurchasesForm, options) {
        return AccountApiFp(this.configuration).lockUserPurchases(uid, foolCommerceDtoLockUserPurchasesForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} uid
     * @param {number} subscriptionId
     * @param {FoolCommerceDtoMemberActionsMemberSubscriptionActionForm} [foolCommerceDtoMemberActionsMemberSubscriptionActionForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    requestAccountSubscriptionAction(uid, subscriptionId, foolCommerceDtoMemberActionsMemberSubscriptionActionForm, options) {
        return AccountApiFp(this.configuration).requestAccountSubscriptionAction(uid, subscriptionId, foolCommerceDtoMemberActionsMemberSubscriptionActionForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set specific payment method to user\'s default payment method
     * @param {number} uid The UID of the user,
     * @param {number} paymentMethodId The ID of the desired Payment Method to set as user\&#39;s default
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    setDefaultPaymentMethodForUser(uid, paymentMethodId, options) {
        return AccountApiFp(this.configuration).setDefaultPaymentMethodForUser(uid, paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Should send Create Password email
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    shouldSendCreatePasswordEmail(email, options) {
        return AccountApiFp(this.configuration).shouldSendCreatePasswordEmail(email, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} uid
     * @param {FoolCommerceDtoUnlockUserPurchasesForm} [foolCommerceDtoUnlockUserPurchasesForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    unlockUserPurchases(uid, foolCommerceDtoUnlockUserPurchasesForm, options) {
        return AccountApiFp(this.configuration).unlockUserPurchases(uid, foolCommerceDtoUnlockUserPurchasesForm, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ChangeLogApi - axios parameter creator
 * @export
 */
export const ChangeLogApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Product Item Change Logs
         * @param {number} productItemId
         * @param {number} [changeType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeLogsForProductItem: async (productItemId, changeType, options = {}) => {
            // verify required parameter 'productItemId' is not null or undefined
            assertParamExists('getChangeLogsForProductItem', 'productItemId', productItemId);
            const localVarPath = `/v1/changelogs/product-item/{productItemId}`
                .replace(`{${"productItemId"}}`, encodeURIComponent(String(productItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (changeType !== undefined) {
                localVarQueryParameter['changeType'] = changeType;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Subscription Change Logs
         * @param {number} subscriptionId
         * @param {number} [changeType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeLogsForSubscription: async (subscriptionId, changeType, options = {}) => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getChangeLogsForSubscription', 'subscriptionId', subscriptionId);
            const localVarPath = `/v1/changelogs/subscription/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (changeType !== undefined) {
                localVarQueryParameter['changeType'] = changeType;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get UID Account Change Logs
         * @param {number} uid
         * @param {number} [changeType]
         * @param {boolean} [excludeSubscriptionLogs]
         * @param {boolean} [excludeProductLogs]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeLogsForUid: async (uid, changeType, excludeSubscriptionLogs, excludeProductLogs, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getChangeLogsForUid', 'uid', uid);
            const localVarPath = `/v1/changelogs/account/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (changeType !== undefined) {
                localVarQueryParameter['changeType'] = changeType;
            }
            if (excludeSubscriptionLogs !== undefined) {
                localVarQueryParameter['excludeSubscriptionLogs'] = excludeSubscriptionLogs;
            }
            if (excludeProductLogs !== undefined) {
                localVarQueryParameter['excludeProductLogs'] = excludeProductLogs;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChangeLogApi - functional programming interface
 * @export
 */
export const ChangeLogApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChangeLogApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get Product Item Change Logs
         * @param {number} productItemId
         * @param {number} [changeType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChangeLogsForProductItem(productItemId, changeType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChangeLogsForProductItem(productItemId, changeType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Subscription Change Logs
         * @param {number} subscriptionId
         * @param {number} [changeType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChangeLogsForSubscription(subscriptionId, changeType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChangeLogsForSubscription(subscriptionId, changeType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get UID Account Change Logs
         * @param {number} uid
         * @param {number} [changeType]
         * @param {boolean} [excludeSubscriptionLogs]
         * @param {boolean} [excludeProductLogs]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChangeLogsForUid(uid, changeType, excludeSubscriptionLogs, excludeProductLogs, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChangeLogsForUid(uid, changeType, excludeSubscriptionLogs, excludeProductLogs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ChangeLogApi - factory interface
 * @export
 */
export const ChangeLogApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ChangeLogApiFp(configuration);
    return {
        /**
         *
         * @summary Get Product Item Change Logs
         * @param {number} productItemId
         * @param {number} [changeType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeLogsForProductItem(productItemId, changeType, options) {
            return localVarFp.getChangeLogsForProductItem(productItemId, changeType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Change Logs
         * @param {number} subscriptionId
         * @param {number} [changeType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeLogsForSubscription(subscriptionId, changeType, options) {
            return localVarFp.getChangeLogsForSubscription(subscriptionId, changeType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get UID Account Change Logs
         * @param {number} uid
         * @param {number} [changeType]
         * @param {boolean} [excludeSubscriptionLogs]
         * @param {boolean} [excludeProductLogs]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeLogsForUid(uid, changeType, excludeSubscriptionLogs, excludeProductLogs, options) {
            return localVarFp.getChangeLogsForUid(uid, changeType, excludeSubscriptionLogs, excludeProductLogs, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChangeLogApi - object-oriented interface
 * @export
 * @class ChangeLogApi
 * @extends {BaseAPI}
 */
export class ChangeLogApi extends BaseAPI {
    /**
     *
     * @summary Get Product Item Change Logs
     * @param {number} productItemId
     * @param {number} [changeType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeLogApi
     */
    getChangeLogsForProductItem(productItemId, changeType, options) {
        return ChangeLogApiFp(this.configuration).getChangeLogsForProductItem(productItemId, changeType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Change Logs
     * @param {number} subscriptionId
     * @param {number} [changeType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeLogApi
     */
    getChangeLogsForSubscription(subscriptionId, changeType, options) {
        return ChangeLogApiFp(this.configuration).getChangeLogsForSubscription(subscriptionId, changeType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get UID Account Change Logs
     * @param {number} uid
     * @param {number} [changeType]
     * @param {boolean} [excludeSubscriptionLogs]
     * @param {boolean} [excludeProductLogs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeLogApi
     */
    getChangeLogsForUid(uid, changeType, excludeSubscriptionLogs, excludeProductLogs, options) {
        return ChangeLogApiFp(this.configuration).getChangeLogsForUid(uid, changeType, excludeSubscriptionLogs, excludeProductLogs, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CreditApi - axios parameter creator
 * @export
 */
export const CreditApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Execute Credit Transfer (formerly Credit Transfer Order)
         * @param {FoolCommerceDtoCreditServiceExecuteCreditTransferRequest} [foolCommerceDtoCreditServiceExecuteCreditTransferRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeCreditTransfer: async (foolCommerceDtoCreditServiceExecuteCreditTransferRequest, options = {}) => {
            const localVarPath = `/v1/credits/credit-transfer-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreditServiceExecuteCreditTransferRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Credit Transfer Quote (formerly \'Subscription Transfer State\')
         * @param {FoolCommerceDtoCreditServiceCreditTransferQuoteRequest} [foolCommerceDtoCreditServiceCreditTransferQuoteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditTransferQuote: async (foolCommerceDtoCreditServiceCreditTransferQuoteRequest, options = {}) => {
            const localVarPath = `/v1/credits/subscription-transfer-state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreditServiceCreditTransferQuoteRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Is User Eligibile For One Time Pro-Rated Refund
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserEligibleForOneTimeProRatedRefund: async (uid, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('isUserEligibleForOneTimeProRatedRefund', 'uid', uid);
            const localVarPath = `/v1/credits/is-user-eligible-for-one-time-pro-rated-refund/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Rollback a Subscription that was transferred using Credit Tool
         * @param {FoolCommerceDtoSubscriptionCreditTransferRollbackForm} [foolCommerceDtoSubscriptionCreditTransferRollbackForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackSubscriptionCreditTransfer: async (foolCommerceDtoSubscriptionCreditTransferRollbackForm, options = {}) => {
            const localVarPath = `/v1/credits/rollback-subscription-transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoSubscriptionCreditTransferRollbackForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Subscription Purchase Amount
         * @param {string} promotion
         * @param {number} offerId
         * @param {number} amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionPurchaseAmount: async (promotion, offerId, amount, options = {}) => {
            // verify required parameter 'promotion' is not null or undefined
            assertParamExists('subscriptionPurchaseAmount', 'promotion', promotion);
            // verify required parameter 'offerId' is not null or undefined
            assertParamExists('subscriptionPurchaseAmount', 'offerId', offerId);
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('subscriptionPurchaseAmount', 'amount', amount);
            const localVarPath = `/v1/credits/subscription-purchase-amount/{promotion}/{offerId}/{amount}`
                .replace(`{${"promotion"}}`, encodeURIComponent(String(promotion)))
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)))
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Subscription Purchase Amounts
         * @param {string} promotion
         * @param {number} amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionPurchaseAmounts: async (promotion, amount, options = {}) => {
            // verify required parameter 'promotion' is not null or undefined
            assertParamExists('subscriptionPurchaseAmounts', 'promotion', promotion);
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('subscriptionPurchaseAmounts', 'amount', amount);
            const localVarPath = `/v1/credits/subscription-purchase-amount/{promotion}/{amount}`
                .replace(`{${"promotion"}}`, encodeURIComponent(String(promotion)))
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Subscription Trade-In Amounts
         * @param {string} promotion
         * @param {number} subscriptionId
         * @param {boolean} [useFullValue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTradeInAmounts: async (promotion, subscriptionId, useFullValue, options = {}) => {
            // verify required parameter 'promotion' is not null or undefined
            assertParamExists('subscriptionTradeInAmounts', 'promotion', promotion);
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('subscriptionTradeInAmounts', 'subscriptionId', subscriptionId);
            const localVarPath = `/v1/credits/subscription-trade-in-amount/{promotion}/{subscriptionId}`
                .replace(`{${"promotion"}}`, encodeURIComponent(String(promotion)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (useFullValue !== undefined) {
                localVarQueryParameter['useFullValue'] = useFullValue;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Subscription Transfer Value
         * @param {number} subscriptionId
         * @param {boolean} [showFullValue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTransferValue: async (subscriptionId, showFullValue, options = {}) => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('subscriptionTransferValue', 'subscriptionId', subscriptionId);
            const localVarPath = `/v1/credits/subscription-transfer-value/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (showFullValue !== undefined) {
                localVarQueryParameter['showFullValue'] = showFullValue;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Pro Rated Refund Eligibility Status
         * @param {FoolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest} [foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProRatedEligibilityStatus: async (foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest, options = {}) => {
            const localVarPath = `/v1/credits/update-pro-rated-refund-eligibility-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CreditApi - functional programming interface
 * @export
 */
export const CreditApiFp = function (configuration) {
    const localVarAxiosParamCreator = CreditApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Execute Credit Transfer (formerly Credit Transfer Order)
         * @param {FoolCommerceDtoCreditServiceExecuteCreditTransferRequest} [foolCommerceDtoCreditServiceExecuteCreditTransferRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeCreditTransfer(foolCommerceDtoCreditServiceExecuteCreditTransferRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeCreditTransfer(foolCommerceDtoCreditServiceExecuteCreditTransferRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Credit Transfer Quote (formerly \'Subscription Transfer State\')
         * @param {FoolCommerceDtoCreditServiceCreditTransferQuoteRequest} [foolCommerceDtoCreditServiceCreditTransferQuoteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditTransferQuote(foolCommerceDtoCreditServiceCreditTransferQuoteRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditTransferQuote(foolCommerceDtoCreditServiceCreditTransferQuoteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Is User Eligibile For One Time Pro-Rated Refund
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUserEligibleForOneTimeProRatedRefund(uid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isUserEligibleForOneTimeProRatedRefund(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Rollback a Subscription that was transferred using Credit Tool
         * @param {FoolCommerceDtoSubscriptionCreditTransferRollbackForm} [foolCommerceDtoSubscriptionCreditTransferRollbackForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollbackSubscriptionCreditTransfer(foolCommerceDtoSubscriptionCreditTransferRollbackForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rollbackSubscriptionCreditTransfer(foolCommerceDtoSubscriptionCreditTransferRollbackForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Subscription Purchase Amount
         * @param {string} promotion
         * @param {number} offerId
         * @param {number} amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionPurchaseAmount(promotion, offerId, amount, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionPurchaseAmount(promotion, offerId, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Subscription Purchase Amounts
         * @param {string} promotion
         * @param {number} amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionPurchaseAmounts(promotion, amount, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionPurchaseAmounts(promotion, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Subscription Trade-In Amounts
         * @param {string} promotion
         * @param {number} subscriptionId
         * @param {boolean} [useFullValue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionTradeInAmounts(promotion, subscriptionId, useFullValue, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionTradeInAmounts(promotion, subscriptionId, useFullValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Subscription Transfer Value
         * @param {number} subscriptionId
         * @param {boolean} [showFullValue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionTransferValue(subscriptionId, showFullValue, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionTransferValue(subscriptionId, showFullValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update Pro Rated Refund Eligibility Status
         * @param {FoolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest} [foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProRatedEligibilityStatus(foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProRatedEligibilityStatus(foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * CreditApi - factory interface
 * @export
 */
export const CreditApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CreditApiFp(configuration);
    return {
        /**
         *
         * @summary Execute Credit Transfer (formerly Credit Transfer Order)
         * @param {FoolCommerceDtoCreditServiceExecuteCreditTransferRequest} [foolCommerceDtoCreditServiceExecuteCreditTransferRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeCreditTransfer(foolCommerceDtoCreditServiceExecuteCreditTransferRequest, options) {
            return localVarFp.executeCreditTransfer(foolCommerceDtoCreditServiceExecuteCreditTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Credit Transfer Quote (formerly \'Subscription Transfer State\')
         * @param {FoolCommerceDtoCreditServiceCreditTransferQuoteRequest} [foolCommerceDtoCreditServiceCreditTransferQuoteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditTransferQuote(foolCommerceDtoCreditServiceCreditTransferQuoteRequest, options) {
            return localVarFp.getCreditTransferQuote(foolCommerceDtoCreditServiceCreditTransferQuoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Is User Eligibile For One Time Pro-Rated Refund
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserEligibleForOneTimeProRatedRefund(uid, options) {
            return localVarFp.isUserEligibleForOneTimeProRatedRefund(uid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Rollback a Subscription that was transferred using Credit Tool
         * @param {FoolCommerceDtoSubscriptionCreditTransferRollbackForm} [foolCommerceDtoSubscriptionCreditTransferRollbackForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackSubscriptionCreditTransfer(foolCommerceDtoSubscriptionCreditTransferRollbackForm, options) {
            return localVarFp.rollbackSubscriptionCreditTransfer(foolCommerceDtoSubscriptionCreditTransferRollbackForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Purchase Amount
         * @param {string} promotion
         * @param {number} offerId
         * @param {number} amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionPurchaseAmount(promotion, offerId, amount, options) {
            return localVarFp.subscriptionPurchaseAmount(promotion, offerId, amount, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Purchase Amounts
         * @param {string} promotion
         * @param {number} amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionPurchaseAmounts(promotion, amount, options) {
            return localVarFp.subscriptionPurchaseAmounts(promotion, amount, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Trade-In Amounts
         * @param {string} promotion
         * @param {number} subscriptionId
         * @param {boolean} [useFullValue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTradeInAmounts(promotion, subscriptionId, useFullValue, options) {
            return localVarFp.subscriptionTradeInAmounts(promotion, subscriptionId, useFullValue, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Transfer Value
         * @param {number} subscriptionId
         * @param {boolean} [showFullValue]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionTransferValue(subscriptionId, showFullValue, options) {
            return localVarFp.subscriptionTransferValue(subscriptionId, showFullValue, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Pro Rated Refund Eligibility Status
         * @param {FoolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest} [foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProRatedEligibilityStatus(foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest, options) {
            return localVarFp.updateProRatedEligibilityStatus(foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
export class CreditApi extends BaseAPI {
    /**
     *
     * @summary Execute Credit Transfer (formerly Credit Transfer Order)
     * @param {FoolCommerceDtoCreditServiceExecuteCreditTransferRequest} [foolCommerceDtoCreditServiceExecuteCreditTransferRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    executeCreditTransfer(foolCommerceDtoCreditServiceExecuteCreditTransferRequest, options) {
        return CreditApiFp(this.configuration).executeCreditTransfer(foolCommerceDtoCreditServiceExecuteCreditTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Credit Transfer Quote (formerly \'Subscription Transfer State\')
     * @param {FoolCommerceDtoCreditServiceCreditTransferQuoteRequest} [foolCommerceDtoCreditServiceCreditTransferQuoteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    getCreditTransferQuote(foolCommerceDtoCreditServiceCreditTransferQuoteRequest, options) {
        return CreditApiFp(this.configuration).getCreditTransferQuote(foolCommerceDtoCreditServiceCreditTransferQuoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Is User Eligibile For One Time Pro-Rated Refund
     * @param {number} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    isUserEligibleForOneTimeProRatedRefund(uid, options) {
        return CreditApiFp(this.configuration).isUserEligibleForOneTimeProRatedRefund(uid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Rollback a Subscription that was transferred using Credit Tool
     * @param {FoolCommerceDtoSubscriptionCreditTransferRollbackForm} [foolCommerceDtoSubscriptionCreditTransferRollbackForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    rollbackSubscriptionCreditTransfer(foolCommerceDtoSubscriptionCreditTransferRollbackForm, options) {
        return CreditApiFp(this.configuration).rollbackSubscriptionCreditTransfer(foolCommerceDtoSubscriptionCreditTransferRollbackForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Purchase Amount
     * @param {string} promotion
     * @param {number} offerId
     * @param {number} amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    subscriptionPurchaseAmount(promotion, offerId, amount, options) {
        return CreditApiFp(this.configuration).subscriptionPurchaseAmount(promotion, offerId, amount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Purchase Amounts
     * @param {string} promotion
     * @param {number} amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    subscriptionPurchaseAmounts(promotion, amount, options) {
        return CreditApiFp(this.configuration).subscriptionPurchaseAmounts(promotion, amount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Trade-In Amounts
     * @param {string} promotion
     * @param {number} subscriptionId
     * @param {boolean} [useFullValue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    subscriptionTradeInAmounts(promotion, subscriptionId, useFullValue, options) {
        return CreditApiFp(this.configuration).subscriptionTradeInAmounts(promotion, subscriptionId, useFullValue, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Transfer Value
     * @param {number} subscriptionId
     * @param {boolean} [showFullValue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    subscriptionTransferValue(subscriptionId, showFullValue, options) {
        return CreditApiFp(this.configuration).subscriptionTransferValue(subscriptionId, showFullValue, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Pro Rated Refund Eligibility Status
     * @param {FoolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest} [foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    updateProRatedEligibilityStatus(foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest, options) {
        return CreditApiFp(this.configuration).updateProRatedEligibilityStatus(foolCommerceDtoCreditServiceUpdateProRatedEligibilityStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DiscountApi - axios parameter creator
 * @export
 */
export const DiscountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Discount Offer
         * @param {number} productId
         * @param {string} [name]
         * @param {string} [expirationDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscountOffer: async (productId, name, expirationDate, options = {}) => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('createDiscountOffer', 'productId', productId);
            const localVarPath = `/v1/discounts/create/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (expirationDate !== undefined) {
                localVarQueryParameter['expirationDate'] = (expirationDate instanceof Date) ?
                    expirationDate.toISOString() :
                    expirationDate;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create Discount Offer With Multiple Products
         * @param {FoolCommerceDtoCreateDiscountForm} [foolCommerceDtoCreateDiscountForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscountOfferWithMultipleProducts: async (foolCommerceDtoCreateDiscountForm, options = {}) => {
            const localVarPath = `/v1/discounts/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreateDiscountForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Decrease User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [amount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decreaseValue: async (discountId, uid, amount, options = {}) => {
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('decreaseValue', 'discountId', discountId);
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('decreaseValue', 'uid', uid);
            const localVarPath = `/v1/discounts/{discountId}/{uid}/decrease`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get All Discount Offers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDiscounts: async (options = {}) => {
            const localVarPath = `/v1/discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (discountId, uid, options = {}) => {
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('getBalance', 'discountId', discountId);
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getBalance', 'uid', uid);
            const localVarPath = `/v1/discounts/{discountId}/{uid}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Discount Offer
         * @param {number} discountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscount: async (discountId, options = {}) => {
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('getDiscount', 'discountId', discountId);
            const localVarPath = `/v1/discounts/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get User Discounts
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDiscounts: async (uid, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getUserDiscounts', 'uid', uid);
            const localVarPath = `/v1/discounts/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Increase User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [amount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        increaseValue: async (discountId, uid, amount, options = {}) => {
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('increaseValue', 'discountId', discountId);
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('increaseValue', 'uid', uid);
            const localVarPath = `/v1/discounts/{discountId}/{uid}/increase`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set multiple User Discounts for a given Discount Offer
         * @param {number} discountId
         * @param {FoolCommerceDtoBulkUserDiscountForm} [foolCommerceDtoBulkUserDiscountForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMultipleUserDiscounts: async (discountId, foolCommerceDtoBulkUserDiscountForm, options = {}) => {
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('setMultipleUserDiscounts', 'discountId', discountId);
            const localVarPath = `/v1/discounts/batch/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoBulkUserDiscountForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setValue: async (discountId, uid, value, options = {}) => {
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('setValue', 'discountId', discountId);
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setValue', 'uid', uid);
            const localVarPath = `/v1/discounts/{discountId}/{uid}/set`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Discount Offer
         * @param {number} discountId
         * @param {string} [name]
         * @param {string} [expirationDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscountOffer: async (discountId, name, expirationDate, options = {}) => {
            // verify required parameter 'discountId' is not null or undefined
            assertParamExists('updateDiscountOffer', 'discountId', discountId);
            const localVarPath = `/v1/discounts/update/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (expirationDate !== undefined) {
                localVarQueryParameter['expirationDate'] = (expirationDate instanceof Date) ?
                    expirationDate.toISOString() :
                    expirationDate;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DiscountApi - functional programming interface
 * @export
 */
export const DiscountApiFp = function (configuration) {
    const localVarAxiosParamCreator = DiscountApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create Discount Offer
         * @param {number} productId
         * @param {string} [name]
         * @param {string} [expirationDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscountOffer(productId, name, expirationDate, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscountOffer(productId, name, expirationDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create Discount Offer With Multiple Products
         * @param {FoolCommerceDtoCreateDiscountForm} [foolCommerceDtoCreateDiscountForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscountOfferWithMultipleProducts(foolCommerceDtoCreateDiscountForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscountOfferWithMultipleProducts(foolCommerceDtoCreateDiscountForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Decrease User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [amount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decreaseValue(discountId, uid, amount, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decreaseValue(discountId, uid, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get All Discount Offers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDiscounts(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDiscounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(discountId, uid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(discountId, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Discount Offer
         * @param {number} discountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscount(discountId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiscount(discountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get User Discounts
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDiscounts(uid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDiscounts(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Increase User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [amount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async increaseValue(discountId, uid, amount, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.increaseValue(discountId, uid, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Set multiple User Discounts for a given Discount Offer
         * @param {number} discountId
         * @param {FoolCommerceDtoBulkUserDiscountForm} [foolCommerceDtoBulkUserDiscountForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMultipleUserDiscounts(discountId, foolCommerceDtoBulkUserDiscountForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMultipleUserDiscounts(discountId, foolCommerceDtoBulkUserDiscountForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Set User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setValue(discountId, uid, value, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setValue(discountId, uid, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update Discount Offer
         * @param {number} discountId
         * @param {string} [name]
         * @param {string} [expirationDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiscountOffer(discountId, name, expirationDate, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiscountOffer(discountId, name, expirationDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DiscountApi - factory interface
 * @export
 */
export const DiscountApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DiscountApiFp(configuration);
    return {
        /**
         *
         * @summary Create Discount Offer
         * @param {number} productId
         * @param {string} [name]
         * @param {string} [expirationDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscountOffer(productId, name, expirationDate, options) {
            return localVarFp.createDiscountOffer(productId, name, expirationDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Discount Offer With Multiple Products
         * @param {FoolCommerceDtoCreateDiscountForm} [foolCommerceDtoCreateDiscountForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscountOfferWithMultipleProducts(foolCommerceDtoCreateDiscountForm, options) {
            return localVarFp.createDiscountOfferWithMultipleProducts(foolCommerceDtoCreateDiscountForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Decrease User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [amount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decreaseValue(discountId, uid, amount, options) {
            return localVarFp.decreaseValue(discountId, uid, amount, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get All Discount Offers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDiscounts(options) {
            return localVarFp.getAllDiscounts(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(discountId, uid, options) {
            return localVarFp.getBalance(discountId, uid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Discount Offer
         * @param {number} discountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscount(discountId, options) {
            return localVarFp.getDiscount(discountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get User Discounts
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDiscounts(uid, options) {
            return localVarFp.getUserDiscounts(uid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Increase User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [amount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        increaseValue(discountId, uid, amount, options) {
            return localVarFp.increaseValue(discountId, uid, amount, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set multiple User Discounts for a given Discount Offer
         * @param {number} discountId
         * @param {FoolCommerceDtoBulkUserDiscountForm} [foolCommerceDtoBulkUserDiscountForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMultipleUserDiscounts(discountId, foolCommerceDtoBulkUserDiscountForm, options) {
            return localVarFp.setMultipleUserDiscounts(discountId, foolCommerceDtoBulkUserDiscountForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set User Discount Balance
         * @param {number} discountId
         * @param {number} uid
         * @param {number} [value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setValue(discountId, uid, value, options) {
            return localVarFp.setValue(discountId, uid, value, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Discount Offer
         * @param {number} discountId
         * @param {string} [name]
         * @param {string} [expirationDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscountOffer(discountId, name, expirationDate, options) {
            return localVarFp.updateDiscountOffer(discountId, name, expirationDate, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DiscountApi - object-oriented interface
 * @export
 * @class DiscountApi
 * @extends {BaseAPI}
 */
export class DiscountApi extends BaseAPI {
    /**
     *
     * @summary Create Discount Offer
     * @param {number} productId
     * @param {string} [name]
     * @param {string} [expirationDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    createDiscountOffer(productId, name, expirationDate, options) {
        return DiscountApiFp(this.configuration).createDiscountOffer(productId, name, expirationDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Discount Offer With Multiple Products
     * @param {FoolCommerceDtoCreateDiscountForm} [foolCommerceDtoCreateDiscountForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    createDiscountOfferWithMultipleProducts(foolCommerceDtoCreateDiscountForm, options) {
        return DiscountApiFp(this.configuration).createDiscountOfferWithMultipleProducts(foolCommerceDtoCreateDiscountForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Decrease User Discount Balance
     * @param {number} discountId
     * @param {number} uid
     * @param {number} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    decreaseValue(discountId, uid, amount, options) {
        return DiscountApiFp(this.configuration).decreaseValue(discountId, uid, amount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get All Discount Offers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    getAllDiscounts(options) {
        return DiscountApiFp(this.configuration).getAllDiscounts(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get User Discount Balance
     * @param {number} discountId
     * @param {number} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    getBalance(discountId, uid, options) {
        return DiscountApiFp(this.configuration).getBalance(discountId, uid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Discount Offer
     * @param {number} discountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    getDiscount(discountId, options) {
        return DiscountApiFp(this.configuration).getDiscount(discountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get User Discounts
     * @param {number} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    getUserDiscounts(uid, options) {
        return DiscountApiFp(this.configuration).getUserDiscounts(uid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Increase User Discount Balance
     * @param {number} discountId
     * @param {number} uid
     * @param {number} [amount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    increaseValue(discountId, uid, amount, options) {
        return DiscountApiFp(this.configuration).increaseValue(discountId, uid, amount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set multiple User Discounts for a given Discount Offer
     * @param {number} discountId
     * @param {FoolCommerceDtoBulkUserDiscountForm} [foolCommerceDtoBulkUserDiscountForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    setMultipleUserDiscounts(discountId, foolCommerceDtoBulkUserDiscountForm, options) {
        return DiscountApiFp(this.configuration).setMultipleUserDiscounts(discountId, foolCommerceDtoBulkUserDiscountForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set User Discount Balance
     * @param {number} discountId
     * @param {number} uid
     * @param {number} [value]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    setValue(discountId, uid, value, options) {
        return DiscountApiFp(this.configuration).setValue(discountId, uid, value, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Discount Offer
     * @param {number} discountId
     * @param {string} [name]
     * @param {string} [expirationDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    updateDiscountOffer(discountId, name, expirationDate, options) {
        return DiscountApiFp(this.configuration).updateDiscountOffer(discountId, name, expirationDate, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * HelpdeskApi - axios parameter creator
 * @export
 */
export const HelpdeskApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns list of macros from Helpdesk API, which are used to Create / Solve Tickets, stored in cache
         * @param {boolean} [refreshCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedMacros: async (refreshCache, options = {}) => {
            const localVarPath = `/v1/helpdesk/macros`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (refreshCache !== undefined) {
                localVarQueryParameter['refreshCache'] = refreshCache;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns all ticket fields from Helpdesk API, stored in cache
         * @param {boolean} [refreshCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedTicketFields: async (refreshCache, options = {}) => {
            const localVarPath = `/v1/helpdesk/ticket-fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (refreshCache !== undefined) {
                localVarQueryParameter['refreshCache'] = refreshCache;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns a macro from Helpdesk API
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMacro: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMacro', 'id', id);
            const localVarPath = `/v1/helpdesk/macros/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns list of helpdesk tickets associated with the given user\'s email address
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHelpdeskTicketsByEmail: async (email, options = {}) => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getUserHelpdeskTicketsByEmail', 'email', email);
            const localVarPath = `/v1/helpdesk/{email}/tickets`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns list of helpdesk tickets associated with the given uid
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHelpdeskTicketsByUid: async (uid, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getUserHelpdeskTicketsByUid', 'uid', uid);
            const localVarPath = `/v1/helpdesk/{uid}/tickets`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * HelpdeskApi - functional programming interface
 * @export
 */
export const HelpdeskApiFp = function (configuration) {
    const localVarAxiosParamCreator = HelpdeskApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Returns list of macros from Helpdesk API, which are used to Create / Solve Tickets, stored in cache
         * @param {boolean} [refreshCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCachedMacros(refreshCache, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCachedMacros(refreshCache, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns all ticket fields from Helpdesk API, stored in cache
         * @param {boolean} [refreshCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCachedTicketFields(refreshCache, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCachedTicketFields(refreshCache, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns a macro from Helpdesk API
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMacro(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMacro(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns list of helpdesk tickets associated with the given user\'s email address
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserHelpdeskTicketsByEmail(email, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserHelpdeskTicketsByEmail(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns list of helpdesk tickets associated with the given uid
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserHelpdeskTicketsByUid(uid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserHelpdeskTicketsByUid(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * HelpdeskApi - factory interface
 * @export
 */
export const HelpdeskApiFactory = function (configuration, basePath, axios) {
    const localVarFp = HelpdeskApiFp(configuration);
    return {
        /**
         *
         * @summary Returns list of macros from Helpdesk API, which are used to Create / Solve Tickets, stored in cache
         * @param {boolean} [refreshCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedMacros(refreshCache, options) {
            return localVarFp.getCachedMacros(refreshCache, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all ticket fields from Helpdesk API, stored in cache
         * @param {boolean} [refreshCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedTicketFields(refreshCache, options) {
            return localVarFp.getCachedTicketFields(refreshCache, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a macro from Helpdesk API
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMacro(id, options) {
            return localVarFp.getMacro(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns list of helpdesk tickets associated with the given user\'s email address
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHelpdeskTicketsByEmail(email, options) {
            return localVarFp.getUserHelpdeskTicketsByEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns list of helpdesk tickets associated with the given uid
         * @param {number} uid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHelpdeskTicketsByUid(uid, options) {
            return localVarFp.getUserHelpdeskTicketsByUid(uid, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HelpdeskApi - object-oriented interface
 * @export
 * @class HelpdeskApi
 * @extends {BaseAPI}
 */
export class HelpdeskApi extends BaseAPI {
    /**
     *
     * @summary Returns list of macros from Helpdesk API, which are used to Create / Solve Tickets, stored in cache
     * @param {boolean} [refreshCache]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpdeskApi
     */
    getCachedMacros(refreshCache, options) {
        return HelpdeskApiFp(this.configuration).getCachedMacros(refreshCache, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all ticket fields from Helpdesk API, stored in cache
     * @param {boolean} [refreshCache]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpdeskApi
     */
    getCachedTicketFields(refreshCache, options) {
        return HelpdeskApiFp(this.configuration).getCachedTicketFields(refreshCache, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a macro from Helpdesk API
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpdeskApi
     */
    getMacro(id, options) {
        return HelpdeskApiFp(this.configuration).getMacro(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns list of helpdesk tickets associated with the given user\'s email address
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpdeskApi
     */
    getUserHelpdeskTicketsByEmail(email, options) {
        return HelpdeskApiFp(this.configuration).getUserHelpdeskTicketsByEmail(email, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns list of helpdesk tickets associated with the given uid
     * @param {number} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpdeskApi
     */
    getUserHelpdeskTicketsByUid(uid, options) {
        return HelpdeskApiFp(this.configuration).getUserHelpdeskTicketsByUid(uid, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create an Apple Pay order
         * @param {FoolCommerceDtoApplePayOrderForm} [foolCommerceDtoApplePayOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptApplePayOrder: async (foolCommerceDtoApplePayOrderForm, options = {}) => {
            const localVarPath = `/v1/orders/apple-pay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoApplePayOrderForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a Comp Order (no Payment Method associated)
         * @param {FoolCommerceDtoCompOrderForm} [foolCommerceDtoCompOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptCompOrder: async (foolCommerceDtoCompOrderForm, options = {}) => {
            const localVarPath = `/v1/orders/comp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCompOrderForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a credit card order
         * @param {FoolCommerceDtoCreditCardOrderForm} [foolCommerceDtoCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptCreditCardOrder: async (foolCommerceDtoCreditCardOrderForm, options = {}) => {
            const localVarPath = `/v1/orders/credit-card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreditCardOrderForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create an ACH order
         * @param {FoolCommerceDtoElectronicCheckOrderForm} [foolCommerceDtoElectronicCheckOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptElectronicCheckOrder: async (foolCommerceDtoElectronicCheckOrderForm, options = {}) => {
            const localVarPath = `/v1/orders/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoElectronicCheckOrderForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create an order with a payment method ID (Fool Pass)
         * @param {FoolCommerceDtoPaymentMethodOrderForm} [foolCommerceDtoPaymentMethodOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPaymentMethodOrder: async (foolCommerceDtoPaymentMethodOrderForm, options = {}) => {
            const localVarPath = `/v1/orders/payment-method`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoPaymentMethodOrderForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a Split Credit Card order
         * @param {FoolCommerceDtoSplitCreditCardOrderForm} [foolCommerceDtoSplitCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptSplitCreditCardOrder: async (foolCommerceDtoSplitCreditCardOrderForm, options = {}) => {
            const localVarPath = `/v1/orders/credit-cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoSplitCreditCardOrderForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Processes a more strict credit card order. Required Security Code
         * @param {FoolCommerceDtoStrictCreditCardOrderForm} [foolCommerceDtoStrictCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptStrictCreditCardOrder: async (foolCommerceDtoStrictCreditCardOrderForm, options = {}) => {
            const localVarPath = `/v1/orders/credit-card-strict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoStrictCreditCardOrderForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns list of users highlighted as potential fraud risk within a specified date range, along with NumberOfOrders placed.  Note: Potential fraud risk is defined as attempting orders with at least 3 different payment methods within a specified number of hours.
         * @param {string} [reportDate] Data type is DATE, not DATETIME.
         * @param {number} [minPaymentMethods] Must be greater than or equal to 3.
         * @param {number} [subsequentPaymentMinutes] Must be less than 1440 (one day).
         * @param {number} [uid]
         * @param {string} [email]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudRiskOrderDetails: async (reportDate, minPaymentMethods, subsequentPaymentMinutes, uid, email, options = {}) => {
            const localVarPath = `/v1/orders/fraud-risk-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (reportDate !== undefined) {
                localVarQueryParameter['reportDate'] = (reportDate instanceof Date) ?
                    reportDate.toISOString() :
                    reportDate;
            }
            if (minPaymentMethods !== undefined) {
                localVarQueryParameter['minPaymentMethods'] = minPaymentMethods;
            }
            if (subsequentPaymentMinutes !== undefined) {
                localVarQueryParameter['subsequentPaymentMinutes'] = subsequentPaymentMinutes;
            }
            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById: async (orderId, options = {}) => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderById', 'orderId', orderId);
            const localVarPath = `/v1/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReceiptByOrderId: async (orderId, options = {}) => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderReceiptByOrderId', 'orderId', orderId);
            const localVarPath = `/v1/orders/receipt/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} orderId
         * @param {boolean} [updateOrderReceiptIfExists]
         * @param {boolean} [publishOrderReceiptGeneratedMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAndPublishOrderReceiptDetail: async (orderId, updateOrderReceiptIfExists, publishOrderReceiptGeneratedMessage, options = {}) => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateAndPublishOrderReceiptDetail', 'orderId', orderId);
            const localVarPath = `/v1/orders/{orderId}/update-publish-receipt-detail`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (updateOrderReceiptIfExists !== undefined) {
                localVarQueryParameter['updateOrderReceiptIfExists'] = updateOrderReceiptIfExists;
            }
            if (publishOrderReceiptGeneratedMessage !== undefined) {
                localVarQueryParameter['publishOrderReceiptGeneratedMessage'] = publishOrderReceiptGeneratedMessage;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create an Apple Pay order
         * @param {FoolCommerceDtoApplePayOrderForm} [foolCommerceDtoApplePayOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptApplePayOrder(foolCommerceDtoApplePayOrderForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptApplePayOrder(foolCommerceDtoApplePayOrderForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a Comp Order (no Payment Method associated)
         * @param {FoolCommerceDtoCompOrderForm} [foolCommerceDtoCompOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptCompOrder(foolCommerceDtoCompOrderForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptCompOrder(foolCommerceDtoCompOrderForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a credit card order
         * @param {FoolCommerceDtoCreditCardOrderForm} [foolCommerceDtoCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptCreditCardOrder(foolCommerceDtoCreditCardOrderForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptCreditCardOrder(foolCommerceDtoCreditCardOrderForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create an ACH order
         * @param {FoolCommerceDtoElectronicCheckOrderForm} [foolCommerceDtoElectronicCheckOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptElectronicCheckOrder(foolCommerceDtoElectronicCheckOrderForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptElectronicCheckOrder(foolCommerceDtoElectronicCheckOrderForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create an order with a payment method ID (Fool Pass)
         * @param {FoolCommerceDtoPaymentMethodOrderForm} [foolCommerceDtoPaymentMethodOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptPaymentMethodOrder(foolCommerceDtoPaymentMethodOrderForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptPaymentMethodOrder(foolCommerceDtoPaymentMethodOrderForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a Split Credit Card order
         * @param {FoolCommerceDtoSplitCreditCardOrderForm} [foolCommerceDtoSplitCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptSplitCreditCardOrder(foolCommerceDtoSplitCreditCardOrderForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptSplitCreditCardOrder(foolCommerceDtoSplitCreditCardOrderForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Processes a more strict credit card order. Required Security Code
         * @param {FoolCommerceDtoStrictCreditCardOrderForm} [foolCommerceDtoStrictCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptStrictCreditCardOrder(foolCommerceDtoStrictCreditCardOrderForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptStrictCreditCardOrder(foolCommerceDtoStrictCreditCardOrderForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns list of users highlighted as potential fraud risk within a specified date range, along with NumberOfOrders placed.  Note: Potential fraud risk is defined as attempting orders with at least 3 different payment methods within a specified number of hours.
         * @param {string} [reportDate] Data type is DATE, not DATETIME.
         * @param {number} [minPaymentMethods] Must be greater than or equal to 3.
         * @param {number} [subsequentPaymentMinutes] Must be less than 1440 (one day).
         * @param {number} [uid]
         * @param {string} [email]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFraudRiskOrderDetails(reportDate, minPaymentMethods, subsequentPaymentMinutes, uid, email, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFraudRiskOrderDetails(reportDate, minPaymentMethods, subsequentPaymentMinutes, uid, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderById(orderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderById(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderReceiptByOrderId(orderId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderReceiptByOrderId(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} orderId
         * @param {boolean} [updateOrderReceiptIfExists]
         * @param {boolean} [publishOrderReceiptGeneratedMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAndPublishOrderReceiptDetail(orderId, updateOrderReceiptIfExists, publishOrderReceiptGeneratedMessage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAndPublishOrderReceiptDetail(orderId, updateOrderReceiptIfExists, publishOrderReceiptGeneratedMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrderApiFp(configuration);
    return {
        /**
         *
         * @summary Create an Apple Pay order
         * @param {FoolCommerceDtoApplePayOrderForm} [foolCommerceDtoApplePayOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptApplePayOrder(foolCommerceDtoApplePayOrderForm, options) {
            return localVarFp.acceptApplePayOrder(foolCommerceDtoApplePayOrderForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a Comp Order (no Payment Method associated)
         * @param {FoolCommerceDtoCompOrderForm} [foolCommerceDtoCompOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptCompOrder(foolCommerceDtoCompOrderForm, options) {
            return localVarFp.acceptCompOrder(foolCommerceDtoCompOrderForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a credit card order
         * @param {FoolCommerceDtoCreditCardOrderForm} [foolCommerceDtoCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptCreditCardOrder(foolCommerceDtoCreditCardOrderForm, options) {
            return localVarFp.acceptCreditCardOrder(foolCommerceDtoCreditCardOrderForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an ACH order
         * @param {FoolCommerceDtoElectronicCheckOrderForm} [foolCommerceDtoElectronicCheckOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptElectronicCheckOrder(foolCommerceDtoElectronicCheckOrderForm, options) {
            return localVarFp.acceptElectronicCheckOrder(foolCommerceDtoElectronicCheckOrderForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an order with a payment method ID (Fool Pass)
         * @param {FoolCommerceDtoPaymentMethodOrderForm} [foolCommerceDtoPaymentMethodOrderForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPaymentMethodOrder(foolCommerceDtoPaymentMethodOrderForm, options) {
            return localVarFp.acceptPaymentMethodOrder(foolCommerceDtoPaymentMethodOrderForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a Split Credit Card order
         * @param {FoolCommerceDtoSplitCreditCardOrderForm} [foolCommerceDtoSplitCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptSplitCreditCardOrder(foolCommerceDtoSplitCreditCardOrderForm, options) {
            return localVarFp.acceptSplitCreditCardOrder(foolCommerceDtoSplitCreditCardOrderForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Processes a more strict credit card order. Required Security Code
         * @param {FoolCommerceDtoStrictCreditCardOrderForm} [foolCommerceDtoStrictCreditCardOrderForm] Credit card order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptStrictCreditCardOrder(foolCommerceDtoStrictCreditCardOrderForm, options) {
            return localVarFp.acceptStrictCreditCardOrder(foolCommerceDtoStrictCreditCardOrderForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns list of users highlighted as potential fraud risk within a specified date range, along with NumberOfOrders placed.  Note: Potential fraud risk is defined as attempting orders with at least 3 different payment methods within a specified number of hours.
         * @param {string} [reportDate] Data type is DATE, not DATETIME.
         * @param {number} [minPaymentMethods] Must be greater than or equal to 3.
         * @param {number} [subsequentPaymentMinutes] Must be less than 1440 (one day).
         * @param {number} [uid]
         * @param {string} [email]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudRiskOrderDetails(reportDate, minPaymentMethods, subsequentPaymentMinutes, uid, email, options) {
            return localVarFp.getFraudRiskOrderDetails(reportDate, minPaymentMethods, subsequentPaymentMinutes, uid, email, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById(orderId, options) {
            return localVarFp.getOrderById(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReceiptByOrderId(orderId, options) {
            return localVarFp.getOrderReceiptByOrderId(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} orderId
         * @param {boolean} [updateOrderReceiptIfExists]
         * @param {boolean} [publishOrderReceiptGeneratedMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAndPublishOrderReceiptDetail(orderId, updateOrderReceiptIfExists, publishOrderReceiptGeneratedMessage, options) {
            return localVarFp.updateAndPublishOrderReceiptDetail(orderId, updateOrderReceiptIfExists, publishOrderReceiptGeneratedMessage, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     *
     * @summary Create an Apple Pay order
     * @param {FoolCommerceDtoApplePayOrderForm} [foolCommerceDtoApplePayOrderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    acceptApplePayOrder(foolCommerceDtoApplePayOrderForm, options) {
        return OrderApiFp(this.configuration).acceptApplePayOrder(foolCommerceDtoApplePayOrderForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a Comp Order (no Payment Method associated)
     * @param {FoolCommerceDtoCompOrderForm} [foolCommerceDtoCompOrderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    acceptCompOrder(foolCommerceDtoCompOrderForm, options) {
        return OrderApiFp(this.configuration).acceptCompOrder(foolCommerceDtoCompOrderForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a credit card order
     * @param {FoolCommerceDtoCreditCardOrderForm} [foolCommerceDtoCreditCardOrderForm] Credit card order details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    acceptCreditCardOrder(foolCommerceDtoCreditCardOrderForm, options) {
        return OrderApiFp(this.configuration).acceptCreditCardOrder(foolCommerceDtoCreditCardOrderForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an ACH order
     * @param {FoolCommerceDtoElectronicCheckOrderForm} [foolCommerceDtoElectronicCheckOrderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    acceptElectronicCheckOrder(foolCommerceDtoElectronicCheckOrderForm, options) {
        return OrderApiFp(this.configuration).acceptElectronicCheckOrder(foolCommerceDtoElectronicCheckOrderForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an order with a payment method ID (Fool Pass)
     * @param {FoolCommerceDtoPaymentMethodOrderForm} [foolCommerceDtoPaymentMethodOrderForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    acceptPaymentMethodOrder(foolCommerceDtoPaymentMethodOrderForm, options) {
        return OrderApiFp(this.configuration).acceptPaymentMethodOrder(foolCommerceDtoPaymentMethodOrderForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a Split Credit Card order
     * @param {FoolCommerceDtoSplitCreditCardOrderForm} [foolCommerceDtoSplitCreditCardOrderForm] Credit card order details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    acceptSplitCreditCardOrder(foolCommerceDtoSplitCreditCardOrderForm, options) {
        return OrderApiFp(this.configuration).acceptSplitCreditCardOrder(foolCommerceDtoSplitCreditCardOrderForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Processes a more strict credit card order. Required Security Code
     * @param {FoolCommerceDtoStrictCreditCardOrderForm} [foolCommerceDtoStrictCreditCardOrderForm] Credit card order details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    acceptStrictCreditCardOrder(foolCommerceDtoStrictCreditCardOrderForm, options) {
        return OrderApiFp(this.configuration).acceptStrictCreditCardOrder(foolCommerceDtoStrictCreditCardOrderForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns list of users highlighted as potential fraud risk within a specified date range, along with NumberOfOrders placed.  Note: Potential fraud risk is defined as attempting orders with at least 3 different payment methods within a specified number of hours.
     * @param {string} [reportDate] Data type is DATE, not DATETIME.
     * @param {number} [minPaymentMethods] Must be greater than or equal to 3.
     * @param {number} [subsequentPaymentMinutes] Must be less than 1440 (one day).
     * @param {number} [uid]
     * @param {string} [email]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    getFraudRiskOrderDetails(reportDate, minPaymentMethods, subsequentPaymentMinutes, uid, email, options) {
        return OrderApiFp(this.configuration).getFraudRiskOrderDetails(reportDate, minPaymentMethods, subsequentPaymentMinutes, uid, email, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    getOrderById(orderId, options) {
        return OrderApiFp(this.configuration).getOrderById(orderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    getOrderReceiptByOrderId(orderId, options) {
        return OrderApiFp(this.configuration).getOrderReceiptByOrderId(orderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} orderId
     * @param {boolean} [updateOrderReceiptIfExists]
     * @param {boolean} [publishOrderReceiptGeneratedMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    updateAndPublishOrderReceiptDetail(orderId, updateOrderReceiptIfExists, publishOrderReceiptGeneratedMessage, options) {
        return OrderApiFp(this.configuration).updateAndPublishOrderReceiptDetail(orderId, updateOrderReceiptIfExists, publishOrderReceiptGeneratedMessage, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PaymentMethodsApi - axios parameter creator
 * @export
 */
export const PaymentMethodsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Save or update a credit card for a given account.
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardForm} [foolCommerceDtoCreditCardForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateCreditCard: async (uid, foolCommerceDtoCreditCardForm, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('addOrUpdateCreditCard', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/payment-methods/credit-card`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreditCardForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Save or update a credit card for a given account.
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardForm} [foolCommerceDtoCreditCardForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateCreditCardForAccount: async (uid, foolCommerceDtoCreditCardForm, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('addOrUpdateCreditCardForAccount', 'uid', uid);
            const localVarPath = `/v1/users/{uid}/payment-methods/credit-card`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreditCardForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Look up a credit card by primary key.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditCardById: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCreditCardById', 'id', id);
            const localVarPath = `/v1/payment-methods/credit-cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Look up a generic payment method by primary key.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodById: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentMethodById', 'id', id);
            const localVarPath = `/v1/payment-methods/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a list of all payment methods on file for a given account, or optionally filters  by payment type (credit card or electronic check).
         * @param {number} uid
         * @param {'CreditCard' | 'ElectronicCheck' | 'ApplePay' | 'Any'} [paymentMethods]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount: async (uid, paymentMethods, countryCode, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getPaymentMethodsForAccount', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/payment-methods`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paymentMethods !== undefined) {
                localVarQueryParameter['paymentMethods'] = paymentMethods;
            }
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Same as GetPaymentMethodsForAccount.
         * @param {number} uid
         * @param {'CreditCard' | 'ElectronicCheck' | 'ApplePay' | 'Any'} [paymentMethods]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForUser: async (uid, paymentMethods, countryCode, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getPaymentMethodsForUser', 'uid', uid);
            const localVarPath = `/v1/users/{uid}/payment-methods`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paymentMethods !== undefined) {
                localVarQueryParameter['paymentMethods'] = paymentMethods;
            }
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update default credit card metadata (everything but the number).
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardMetadataForm} [foolCommerceDtoCreditCardMetadataForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultCreditCardMetadata: async (uid, foolCommerceDtoCreditCardMetadataForm, options = {}) => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDefaultCreditCardMetadata', 'uid', uid);
            const localVarPath = `/v1/accounts/{uid}/payment-methods/credit-card-metadata`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreditCardMetadataForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentMethodsApi - functional programming interface
 * @export
 */
export const PaymentMethodsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PaymentMethodsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Save or update a credit card for a given account.
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardForm} [foolCommerceDtoCreditCardForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrUpdateCreditCard(uid, foolCommerceDtoCreditCardForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrUpdateCreditCard(uid, foolCommerceDtoCreditCardForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Save or update a credit card for a given account.
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardForm} [foolCommerceDtoCreditCardForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrUpdateCreditCardForAccount(uid, foolCommerceDtoCreditCardForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrUpdateCreditCardForAccount(uid, foolCommerceDtoCreditCardForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Look up a credit card by primary key.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditCardById(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditCardById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Look up a generic payment method by primary key.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodById(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a list of all payment methods on file for a given account, or optionally filters  by payment type (credit card or electronic check).
         * @param {number} uid
         * @param {'CreditCard' | 'ElectronicCheck' | 'ApplePay' | 'Any'} [paymentMethods]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodsForAccount(uid, paymentMethods, countryCode, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodsForAccount(uid, paymentMethods, countryCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Same as GetPaymentMethodsForAccount.
         * @param {number} uid
         * @param {'CreditCard' | 'ElectronicCheck' | 'ApplePay' | 'Any'} [paymentMethods]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodsForUser(uid, paymentMethods, countryCode, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodsForUser(uid, paymentMethods, countryCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update default credit card metadata (everything but the number).
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardMetadataForm} [foolCommerceDtoCreditCardMetadataForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDefaultCreditCardMetadata(uid, foolCommerceDtoCreditCardMetadataForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDefaultCreditCardMetadata(uid, foolCommerceDtoCreditCardMetadataForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PaymentMethodsApi - factory interface
 * @export
 */
export const PaymentMethodsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PaymentMethodsApiFp(configuration);
    return {
        /**
         *
         * @summary Save or update a credit card for a given account.
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardForm} [foolCommerceDtoCreditCardForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateCreditCard(uid, foolCommerceDtoCreditCardForm, options) {
            return localVarFp.addOrUpdateCreditCard(uid, foolCommerceDtoCreditCardForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Save or update a credit card for a given account.
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardForm} [foolCommerceDtoCreditCardForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateCreditCardForAccount(uid, foolCommerceDtoCreditCardForm, options) {
            return localVarFp.addOrUpdateCreditCardForAccount(uid, foolCommerceDtoCreditCardForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Look up a credit card by primary key.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditCardById(id, options) {
            return localVarFp.getCreditCardById(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Look up a generic payment method by primary key.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodById(id, options) {
            return localVarFp.getPaymentMethodById(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a list of all payment methods on file for a given account, or optionally filters  by payment type (credit card or electronic check).
         * @param {number} uid
         * @param {'CreditCard' | 'ElectronicCheck' | 'ApplePay' | 'Any'} [paymentMethods]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount(uid, paymentMethods, countryCode, options) {
            return localVarFp.getPaymentMethodsForAccount(uid, paymentMethods, countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Same as GetPaymentMethodsForAccount.
         * @param {number} uid
         * @param {'CreditCard' | 'ElectronicCheck' | 'ApplePay' | 'Any'} [paymentMethods]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForUser(uid, paymentMethods, countryCode, options) {
            return localVarFp.getPaymentMethodsForUser(uid, paymentMethods, countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update default credit card metadata (everything but the number).
         * @param {number} uid
         * @param {FoolCommerceDtoCreditCardMetadataForm} [foolCommerceDtoCreditCardMetadataForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultCreditCardMetadata(uid, foolCommerceDtoCreditCardMetadataForm, options) {
            return localVarFp.updateDefaultCreditCardMetadata(uid, foolCommerceDtoCreditCardMetadataForm, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PaymentMethodsApi - object-oriented interface
 * @export
 * @class PaymentMethodsApi
 * @extends {BaseAPI}
 */
export class PaymentMethodsApi extends BaseAPI {
    /**
     *
     * @summary Save or update a credit card for a given account.
     * @param {number} uid
     * @param {FoolCommerceDtoCreditCardForm} [foolCommerceDtoCreditCardForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    addOrUpdateCreditCard(uid, foolCommerceDtoCreditCardForm, options) {
        return PaymentMethodsApiFp(this.configuration).addOrUpdateCreditCard(uid, foolCommerceDtoCreditCardForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Save or update a credit card for a given account.
     * @param {number} uid
     * @param {FoolCommerceDtoCreditCardForm} [foolCommerceDtoCreditCardForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    addOrUpdateCreditCardForAccount(uid, foolCommerceDtoCreditCardForm, options) {
        return PaymentMethodsApiFp(this.configuration).addOrUpdateCreditCardForAccount(uid, foolCommerceDtoCreditCardForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Look up a credit card by primary key.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    getCreditCardById(id, options) {
        return PaymentMethodsApiFp(this.configuration).getCreditCardById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Look up a generic payment method by primary key.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    getPaymentMethodById(id, options) {
        return PaymentMethodsApiFp(this.configuration).getPaymentMethodById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a list of all payment methods on file for a given account, or optionally filters  by payment type (credit card or electronic check).
     * @param {number} uid
     * @param {'CreditCard' | 'ElectronicCheck' | 'ApplePay' | 'Any'} [paymentMethods]
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    getPaymentMethodsForAccount(uid, paymentMethods, countryCode, options) {
        return PaymentMethodsApiFp(this.configuration).getPaymentMethodsForAccount(uid, paymentMethods, countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Same as GetPaymentMethodsForAccount.
     * @param {number} uid
     * @param {'CreditCard' | 'ElectronicCheck' | 'ApplePay' | 'Any'} [paymentMethods]
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    getPaymentMethodsForUser(uid, paymentMethods, countryCode, options) {
        return PaymentMethodsApiFp(this.configuration).getPaymentMethodsForUser(uid, paymentMethods, countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update default credit card metadata (everything but the number).
     * @param {number} uid
     * @param {FoolCommerceDtoCreditCardMetadataForm} [foolCommerceDtoCreditCardMetadataForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    updateDefaultCreditCardMetadata(uid, foolCommerceDtoCreditCardMetadataForm, options) {
        return PaymentMethodsApiFp(this.configuration).updateDefaultCreditCardMetadata(uid, foolCommerceDtoCreditCardMetadataForm, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Single Item Product
         * @param {FoolCommerceDtoCreateSingleItemProductForm} [foolCommerceDtoCreateSingleItemProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSingleItemProduct: async (foolCommerceDtoCreateSingleItemProductForm, options = {}) => {
            const localVarPath = `/v1/products/single-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreateSingleItemProductForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create Subscription Product
         * @param {FoolCommerceDtoCreateSubscriptionProductForm} [foolCommerceDtoCreateSubscriptionProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionProduct: async (foolCommerceDtoCreateSubscriptionProductForm, options = {}) => {
            const localVarPath = `/v1/products/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreateSubscriptionProductForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create Subscription Product Term
         * @param {number} productId
         * @param {FoolCommerceDtoCreateSubscriptionProductTermForm} [foolCommerceDtoCreateSubscriptionProductTermForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionProductTerm: async (productId, foolCommerceDtoCreateSubscriptionProductTermForm, options = {}) => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('createSubscriptionProductTerm', 'productId', productId);
            const localVarPath = `/v1/products/subscriptions/{productId}/terms`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreateSubscriptionProductTermForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get SingleItem Product
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleItemProduct: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleItemProduct', 'id', id);
            const localVarPath = `/v1/products/single-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Subscription Product
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionProduct: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionProduct', 'id', id);
            const localVarPath = `/v1/products/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Active Subscription Products
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionProducts: async (countryCode, options = {}) => {
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('getSubscriptionProducts', 'countryCode', countryCode);
            const localVarPath = `/v1/products/subscriptions/{countryCode}`
                .replace(`{${"countryCode"}}`, encodeURIComponent(String(countryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Products matching filter criteria.
         * @param {string} [name] Optionally filter on product name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSingleItemProducts: async (name, limit, offset, options = {}) => {
            const localVarPath = `/v1/products/single-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Subscription Products matching filter criteria.
         * @param {string} [name] Optionally filter on product name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionProducts: async (name, limit, offset, options = {}) => {
            const localVarPath = `/v1/products/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update SingleItem Product
         * @param {number} id
         * @param {FoolCommerceDtoUpdateSingleItemProductForm} [foolCommerceDtoUpdateSingleItemProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemProduct: async (id, foolCommerceDtoUpdateSingleItemProductForm, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemProduct', 'id', id);
            const localVarPath = `/v1/products/single-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoUpdateSingleItemProductForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Subscription Product
         * @param {number} id
         * @param {FoolCommerceDtoUpdateSubscriptionProductForm} [foolCommerceDtoUpdateSubscriptionProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionProduct: async (id, foolCommerceDtoUpdateSubscriptionProductForm, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSubscriptionProduct', 'id', id);
            const localVarPath = `/v1/products/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoUpdateSubscriptionProductForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} productId
         * @param {FoolCommerceDtoUpdateSubscriptionProductLevelForm} [foolCommerceDtoUpdateSubscriptionProductLevelForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionProductLevel: async (productId, foolCommerceDtoUpdateSubscriptionProductLevelForm, options = {}) => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('updateSubscriptionProductLevel', 'productId', productId);
            const localVarPath = `/v1/products/subscriptions/{productId}/update-level`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoUpdateSubscriptionProductLevelForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function (configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create Single Item Product
         * @param {FoolCommerceDtoCreateSingleItemProductForm} [foolCommerceDtoCreateSingleItemProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSingleItemProduct(foolCommerceDtoCreateSingleItemProductForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSingleItemProduct(foolCommerceDtoCreateSingleItemProductForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create Subscription Product
         * @param {FoolCommerceDtoCreateSubscriptionProductForm} [foolCommerceDtoCreateSubscriptionProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionProduct(foolCommerceDtoCreateSubscriptionProductForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionProduct(foolCommerceDtoCreateSubscriptionProductForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create Subscription Product Term
         * @param {number} productId
         * @param {FoolCommerceDtoCreateSubscriptionProductTermForm} [foolCommerceDtoCreateSubscriptionProductTermForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionProductTerm(productId, foolCommerceDtoCreateSubscriptionProductTermForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionProductTerm(productId, foolCommerceDtoCreateSubscriptionProductTermForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get SingleItem Product
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleItemProduct(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleItemProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Subscription Product
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionProduct(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Active Subscription Products
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionProducts(countryCode, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionProducts(countryCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Products matching filter criteria.
         * @param {string} [name] Optionally filter on product name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSingleItemProducts(name, limit, offset, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSingleItemProducts(name, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Subscription Products matching filter criteria.
         * @param {string} [name] Optionally filter on product name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionProducts(name, limit, offset, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionProducts(name, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update SingleItem Product
         * @param {number} id
         * @param {FoolCommerceDtoUpdateSingleItemProductForm} [foolCommerceDtoUpdateSingleItemProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemProduct(id, foolCommerceDtoUpdateSingleItemProductForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemProduct(id, foolCommerceDtoUpdateSingleItemProductForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update Subscription Product
         * @param {number} id
         * @param {FoolCommerceDtoUpdateSubscriptionProductForm} [foolCommerceDtoUpdateSubscriptionProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionProduct(id, foolCommerceDtoUpdateSubscriptionProductForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionProduct(id, foolCommerceDtoUpdateSubscriptionProductForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} productId
         * @param {FoolCommerceDtoUpdateSubscriptionProductLevelForm} [foolCommerceDtoUpdateSubscriptionProductLevelForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionProductLevel(productId, foolCommerceDtoUpdateSubscriptionProductLevelForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionProductLevel(productId, foolCommerceDtoUpdateSubscriptionProductLevelForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ProductApiFp(configuration);
    return {
        /**
         *
         * @summary Create Single Item Product
         * @param {FoolCommerceDtoCreateSingleItemProductForm} [foolCommerceDtoCreateSingleItemProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSingleItemProduct(foolCommerceDtoCreateSingleItemProductForm, options) {
            return localVarFp.createSingleItemProduct(foolCommerceDtoCreateSingleItemProductForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Subscription Product
         * @param {FoolCommerceDtoCreateSubscriptionProductForm} [foolCommerceDtoCreateSubscriptionProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionProduct(foolCommerceDtoCreateSubscriptionProductForm, options) {
            return localVarFp.createSubscriptionProduct(foolCommerceDtoCreateSubscriptionProductForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Subscription Product Term
         * @param {number} productId
         * @param {FoolCommerceDtoCreateSubscriptionProductTermForm} [foolCommerceDtoCreateSubscriptionProductTermForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionProductTerm(productId, foolCommerceDtoCreateSubscriptionProductTermForm, options) {
            return localVarFp.createSubscriptionProductTerm(productId, foolCommerceDtoCreateSubscriptionProductTermForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get SingleItem Product
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleItemProduct(id, options) {
            return localVarFp.getSingleItemProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Subscription Product
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionProduct(id, options) {
            return localVarFp.getSubscriptionProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Active Subscription Products
         * @param {string} countryCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionProducts(countryCode, options) {
            return localVarFp.getSubscriptionProducts(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Products matching filter criteria.
         * @param {string} [name] Optionally filter on product name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSingleItemProducts(name, limit, offset, options) {
            return localVarFp.listSingleItemProducts(name, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Subscription Products matching filter criteria.
         * @param {string} [name] Optionally filter on product name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionProducts(name, limit, offset, options) {
            return localVarFp.listSubscriptionProducts(name, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update SingleItem Product
         * @param {number} id
         * @param {FoolCommerceDtoUpdateSingleItemProductForm} [foolCommerceDtoUpdateSingleItemProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemProduct(id, foolCommerceDtoUpdateSingleItemProductForm, options) {
            return localVarFp.updateSingleItemProduct(id, foolCommerceDtoUpdateSingleItemProductForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Subscription Product
         * @param {number} id
         * @param {FoolCommerceDtoUpdateSubscriptionProductForm} [foolCommerceDtoUpdateSubscriptionProductForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionProduct(id, foolCommerceDtoUpdateSubscriptionProductForm, options) {
            return localVarFp.updateSubscriptionProduct(id, foolCommerceDtoUpdateSubscriptionProductForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} productId
         * @param {FoolCommerceDtoUpdateSubscriptionProductLevelForm} [foolCommerceDtoUpdateSubscriptionProductLevelForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionProductLevel(productId, foolCommerceDtoUpdateSubscriptionProductLevelForm, options) {
            return localVarFp.updateSubscriptionProductLevel(productId, foolCommerceDtoUpdateSubscriptionProductLevelForm, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     *
     * @summary Create Single Item Product
     * @param {FoolCommerceDtoCreateSingleItemProductForm} [foolCommerceDtoCreateSingleItemProductForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    createSingleItemProduct(foolCommerceDtoCreateSingleItemProductForm, options) {
        return ProductApiFp(this.configuration).createSingleItemProduct(foolCommerceDtoCreateSingleItemProductForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Subscription Product
     * @param {FoolCommerceDtoCreateSubscriptionProductForm} [foolCommerceDtoCreateSubscriptionProductForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    createSubscriptionProduct(foolCommerceDtoCreateSubscriptionProductForm, options) {
        return ProductApiFp(this.configuration).createSubscriptionProduct(foolCommerceDtoCreateSubscriptionProductForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Subscription Product Term
     * @param {number} productId
     * @param {FoolCommerceDtoCreateSubscriptionProductTermForm} [foolCommerceDtoCreateSubscriptionProductTermForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    createSubscriptionProductTerm(productId, foolCommerceDtoCreateSubscriptionProductTermForm, options) {
        return ProductApiFp(this.configuration).createSubscriptionProductTerm(productId, foolCommerceDtoCreateSubscriptionProductTermForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get SingleItem Product
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    getSingleItemProduct(id, options) {
        return ProductApiFp(this.configuration).getSingleItemProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Subscription Product
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    getSubscriptionProduct(id, options) {
        return ProductApiFp(this.configuration).getSubscriptionProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Active Subscription Products
     * @param {string} countryCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    getSubscriptionProducts(countryCode, options) {
        return ProductApiFp(this.configuration).getSubscriptionProducts(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Products matching filter criteria.
     * @param {string} [name] Optionally filter on product name contains value.
     * @param {number} [limit] Optionally limit number of results.
     * @param {number} [offset] Optionally skip number of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    listSingleItemProducts(name, limit, offset, options) {
        return ProductApiFp(this.configuration).listSingleItemProducts(name, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Subscription Products matching filter criteria.
     * @param {string} [name] Optionally filter on product name contains value.
     * @param {number} [limit] Optionally limit number of results.
     * @param {number} [offset] Optionally skip number of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    listSubscriptionProducts(name, limit, offset, options) {
        return ProductApiFp(this.configuration).listSubscriptionProducts(name, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update SingleItem Product
     * @param {number} id
     * @param {FoolCommerceDtoUpdateSingleItemProductForm} [foolCommerceDtoUpdateSingleItemProductForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    updateSingleItemProduct(id, foolCommerceDtoUpdateSingleItemProductForm, options) {
        return ProductApiFp(this.configuration).updateSingleItemProduct(id, foolCommerceDtoUpdateSingleItemProductForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Subscription Product
     * @param {number} id
     * @param {FoolCommerceDtoUpdateSubscriptionProductForm} [foolCommerceDtoUpdateSubscriptionProductForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    updateSubscriptionProduct(id, foolCommerceDtoUpdateSubscriptionProductForm, options) {
        return ProductApiFp(this.configuration).updateSubscriptionProduct(id, foolCommerceDtoUpdateSubscriptionProductForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} productId
     * @param {FoolCommerceDtoUpdateSubscriptionProductLevelForm} [foolCommerceDtoUpdateSubscriptionProductLevelForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    updateSubscriptionProductLevel(productId, foolCommerceDtoUpdateSubscriptionProductLevelForm, options) {
        return ProductApiFp(this.configuration).updateSubscriptionProductLevel(productId, foolCommerceDtoUpdateSubscriptionProductLevelForm, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ProductOfferApi - axios parameter creator
 * @export
 */
export const ProductOfferApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Active Premiums
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePremiums: async (countryCode, options = {}) => {
            const localVarPath = `/v1/offers/premiums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Active Product Offers
         * @param {string} [countryCode]
         * @param {'SingleItem' | 'Subscription' | 'Any'} [productOfferType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProductOffers: async (countryCode, productOfferType, options = {}) => {
            const localVarPath = `/v1/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            if (productOfferType !== undefined) {
                localVarQueryParameter['productOfferType'] = productOfferType;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ProductOfferApi - functional programming interface
 * @export
 */
export const ProductOfferApiFp = function (configuration) {
    const localVarAxiosParamCreator = ProductOfferApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get Active Premiums
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivePremiums(countryCode, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivePremiums(countryCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Active Product Offers
         * @param {string} [countryCode]
         * @param {'SingleItem' | 'Subscription' | 'Any'} [productOfferType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveProductOffers(countryCode, productOfferType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveProductOffers(countryCode, productOfferType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ProductOfferApi - factory interface
 * @export
 */
export const ProductOfferApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ProductOfferApiFp(configuration);
    return {
        /**
         *
         * @summary Get Active Premiums
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePremiums(countryCode, options) {
            return localVarFp.getActivePremiums(countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Active Product Offers
         * @param {string} [countryCode]
         * @param {'SingleItem' | 'Subscription' | 'Any'} [productOfferType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProductOffers(countryCode, productOfferType, options) {
            return localVarFp.getActiveProductOffers(countryCode, productOfferType, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductOfferApi - object-oriented interface
 * @export
 * @class ProductOfferApi
 * @extends {BaseAPI}
 */
export class ProductOfferApi extends BaseAPI {
    /**
     *
     * @summary Get Active Premiums
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductOfferApi
     */
    getActivePremiums(countryCode, options) {
        return ProductOfferApiFp(this.configuration).getActivePremiums(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Active Product Offers
     * @param {string} [countryCode]
     * @param {'SingleItem' | 'Subscription' | 'Any'} [productOfferType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductOfferApi
     */
    getActiveProductOffers(countryCode, productOfferType, options) {
        return ProductOfferApiFp(this.configuration).getActiveProductOffers(countryCode, productOfferType, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PromotionApi - axios parameter creator
 * @export
 */
export const PromotionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create Promotion V1 ** General use Create Promotion call, currently used by admin-ui **
         * @param {FoolCommerceDtoCreatePromotionForm} [foolCommerceDtoCreatePromotionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromotion: async (foolCommerceDtoCreatePromotionForm, options = {}) => {
            const localVarPath = `/v1/promotions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoCreatePromotionForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudienceTypes: async (options = {}) => {
            const localVarPath = `/v1/promotions/audience-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Promotion
         * @param {number} id
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromotion: async (id, countryCode, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPromotion', 'id', id);
            const localVarPath = `/v1/promotions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Promotion By Code
         * @param {string} promotionCode
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromotionByCode: async (promotionCode, countryCode, options = {}) => {
            // verify required parameter 'promotionCode' is not null or undefined
            assertParamExists('getPromotionByCode', 'promotionCode', promotionCode);
            const localVarPath = `/v1/promotions/{promotionCode}`
                .replace(`{${"promotionCode"}}`, encodeURIComponent(String(promotionCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Promotions matching filter criteria.
         * @param {string} [name] Optionally filter on promotion name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromotions: async (name, limit, offset, options = {}) => {
            const localVarPath = `/v1/promotions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a SolrSearchResponse given various query parameters
         * @param {string} [searchQuery]
         * @param {string} [countryCode]
         * @param {number} [rows]
         * @param {number} [startRow]
         * @param {boolean} [activeOnly]
         * @param {Array<string>} [premiumProductNames]
         * @param {string} [productName]
         * @param {string} [subscriptionTerm]
         * @param {number} [acquisitionPrice]
         * @param {number} [campaignId]
         * @param {Array<'NewMember' | 'Retention' | 'Acquisition'>} [audienceTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSolrOfferDocuments: async (searchQuery, countryCode, rows, startRow, activeOnly, premiumProductNames, productName, subscriptionTerm, acquisitionPrice, campaignId, audienceTypes, options = {}) => {
            const localVarPath = `/v1/promotions/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (searchQuery !== undefined) {
                localVarQueryParameter['searchQuery'] = searchQuery;
            }
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            if (rows !== undefined) {
                localVarQueryParameter['rows'] = rows;
            }
            if (startRow !== undefined) {
                localVarQueryParameter['startRow'] = startRow;
            }
            if (activeOnly !== undefined) {
                localVarQueryParameter['activeOnly'] = activeOnly;
            }
            if (premiumProductNames) {
                localVarQueryParameter['premiumProductNames'] = premiumProductNames;
            }
            if (productName !== undefined) {
                localVarQueryParameter['productName'] = productName;
            }
            if (subscriptionTerm !== undefined) {
                localVarQueryParameter['subscriptionTerm'] = subscriptionTerm;
            }
            if (acquisitionPrice !== undefined) {
                localVarQueryParameter['acquisitionPrice'] = acquisitionPrice;
            }
            if (campaignId !== undefined) {
                localVarQueryParameter['campaignId'] = campaignId;
            }
            if (audienceTypes) {
                localVarQueryParameter['audienceTypes'] = audienceTypes;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Promotion V1 ** General use Update Promotion call, currently used by admin-ui **
         * @param {number} id
         * @param {FoolCommerceDtoUpdatePromotionForm} [foolCommerceDtoUpdatePromotionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromotion: async (id, foolCommerceDtoUpdatePromotionForm, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePromotion', 'id', id);
            const localVarPath = `/v1/promotions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoUpdatePromotionForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Single Item Offer (Update Promotion Offer)
         * @param {number} promotionId
         * @param {number} offerId
         * @param {string} [countryCode]
         * @param {FoolCommerceDtoUpdateOfferForm} [foolCommerceDtoUpdateOfferForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemOffer: async (promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options = {}) => {
            // verify required parameter 'promotionId' is not null or undefined
            assertParamExists('updateSingleItemOffer', 'promotionId', promotionId);
            // verify required parameter 'offerId' is not null or undefined
            assertParamExists('updateSingleItemOffer', 'offerId', offerId);
            const localVarPath = `/v1/promotions/{promotionId}/offers/single-item/{offerId}`
                .replace(`{${"promotionId"}}`, encodeURIComponent(String(promotionId)))
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoUpdateOfferForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Subscription Offer (Update Promotion Offer)
         * @param {number} promotionId
         * @param {number} offerId
         * @param {string} [countryCode]
         * @param {FoolCommerceDtoUpdateOfferForm} [foolCommerceDtoUpdateOfferForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionOffer: async (promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options = {}) => {
            // verify required parameter 'promotionId' is not null or undefined
            assertParamExists('updateSubscriptionOffer', 'promotionId', promotionId);
            // verify required parameter 'offerId' is not null or undefined
            assertParamExists('updateSubscriptionOffer', 'offerId', offerId);
            const localVarPath = `/v1/promotions/{promotionId}/offers/subscription/{offerId}`
                .replace(`{${"promotionId"}}`, encodeURIComponent(String(promotionId)))
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoUpdateOfferForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PromotionApi - functional programming interface
 * @export
 */
export const PromotionApiFp = function (configuration) {
    const localVarAxiosParamCreator = PromotionApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create Promotion V1 ** General use Create Promotion call, currently used by admin-ui **
         * @param {FoolCommerceDtoCreatePromotionForm} [foolCommerceDtoCreatePromotionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPromotion(foolCommerceDtoCreatePromotionForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPromotion(foolCommerceDtoCreatePromotionForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudienceTypes(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAudienceTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Promotion
         * @param {number} id
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromotion(id, countryCode, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromotion(id, countryCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Promotion By Code
         * @param {string} promotionCode
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromotionByCode(promotionCode, countryCode, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromotionByCode(promotionCode, countryCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Promotions matching filter criteria.
         * @param {string} [name] Optionally filter on promotion name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromotions(name, limit, offset, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPromotions(name, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a SolrSearchResponse given various query parameters
         * @param {string} [searchQuery]
         * @param {string} [countryCode]
         * @param {number} [rows]
         * @param {number} [startRow]
         * @param {boolean} [activeOnly]
         * @param {Array<string>} [premiumProductNames]
         * @param {string} [productName]
         * @param {string} [subscriptionTerm]
         * @param {number} [acquisitionPrice]
         * @param {number} [campaignId]
         * @param {Array<'NewMember' | 'Retention' | 'Acquisition'>} [audienceTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSolrOfferDocuments(searchQuery, countryCode, rows, startRow, activeOnly, premiumProductNames, productName, subscriptionTerm, acquisitionPrice, campaignId, audienceTypes, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSolrOfferDocuments(searchQuery, countryCode, rows, startRow, activeOnly, premiumProductNames, productName, subscriptionTerm, acquisitionPrice, campaignId, audienceTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update Promotion V1 ** General use Update Promotion call, currently used by admin-ui **
         * @param {number} id
         * @param {FoolCommerceDtoUpdatePromotionForm} [foolCommerceDtoUpdatePromotionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePromotion(id, foolCommerceDtoUpdatePromotionForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePromotion(id, foolCommerceDtoUpdatePromotionForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update Single Item Offer (Update Promotion Offer)
         * @param {number} promotionId
         * @param {number} offerId
         * @param {string} [countryCode]
         * @param {FoolCommerceDtoUpdateOfferForm} [foolCommerceDtoUpdateOfferForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update Subscription Offer (Update Promotion Offer)
         * @param {number} promotionId
         * @param {number} offerId
         * @param {string} [countryCode]
         * @param {FoolCommerceDtoUpdateOfferForm} [foolCommerceDtoUpdateOfferForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PromotionApi - factory interface
 * @export
 */
export const PromotionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PromotionApiFp(configuration);
    return {
        /**
         *
         * @summary Create Promotion V1 ** General use Create Promotion call, currently used by admin-ui **
         * @param {FoolCommerceDtoCreatePromotionForm} [foolCommerceDtoCreatePromotionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromotion(foolCommerceDtoCreatePromotionForm, options) {
            return localVarFp.createPromotion(foolCommerceDtoCreatePromotionForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudienceTypes(options) {
            return localVarFp.getAudienceTypes(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Promotion
         * @param {number} id
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromotion(id, countryCode, options) {
            return localVarFp.getPromotion(id, countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Promotion By Code
         * @param {string} promotionCode
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromotionByCode(promotionCode, countryCode, options) {
            return localVarFp.getPromotionByCode(promotionCode, countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Promotions matching filter criteria.
         * @param {string} [name] Optionally filter on promotion name contains value.
         * @param {number} [limit] Optionally limit number of results.
         * @param {number} [offset] Optionally skip number of results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromotions(name, limit, offset, options) {
            return localVarFp.listPromotions(name, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a SolrSearchResponse given various query parameters
         * @param {string} [searchQuery]
         * @param {string} [countryCode]
         * @param {number} [rows]
         * @param {number} [startRow]
         * @param {boolean} [activeOnly]
         * @param {Array<string>} [premiumProductNames]
         * @param {string} [productName]
         * @param {string} [subscriptionTerm]
         * @param {number} [acquisitionPrice]
         * @param {number} [campaignId]
         * @param {Array<'NewMember' | 'Retention' | 'Acquisition'>} [audienceTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSolrOfferDocuments(searchQuery, countryCode, rows, startRow, activeOnly, premiumProductNames, productName, subscriptionTerm, acquisitionPrice, campaignId, audienceTypes, options) {
            return localVarFp.searchSolrOfferDocuments(searchQuery, countryCode, rows, startRow, activeOnly, premiumProductNames, productName, subscriptionTerm, acquisitionPrice, campaignId, audienceTypes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Promotion V1 ** General use Update Promotion call, currently used by admin-ui **
         * @param {number} id
         * @param {FoolCommerceDtoUpdatePromotionForm} [foolCommerceDtoUpdatePromotionForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromotion(id, foolCommerceDtoUpdatePromotionForm, options) {
            return localVarFp.updatePromotion(id, foolCommerceDtoUpdatePromotionForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Single Item Offer (Update Promotion Offer)
         * @param {number} promotionId
         * @param {number} offerId
         * @param {string} [countryCode]
         * @param {FoolCommerceDtoUpdateOfferForm} [foolCommerceDtoUpdateOfferForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options) {
            return localVarFp.updateSingleItemOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Subscription Offer (Update Promotion Offer)
         * @param {number} promotionId
         * @param {number} offerId
         * @param {string} [countryCode]
         * @param {FoolCommerceDtoUpdateOfferForm} [foolCommerceDtoUpdateOfferForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options) {
            return localVarFp.updateSubscriptionOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PromotionApi - object-oriented interface
 * @export
 * @class PromotionApi
 * @extends {BaseAPI}
 */
export class PromotionApi extends BaseAPI {
    /**
     *
     * @summary Create Promotion V1 ** General use Create Promotion call, currently used by admin-ui **
     * @param {FoolCommerceDtoCreatePromotionForm} [foolCommerceDtoCreatePromotionForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    createPromotion(foolCommerceDtoCreatePromotionForm, options) {
        return PromotionApiFp(this.configuration).createPromotion(foolCommerceDtoCreatePromotionForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    getAudienceTypes(options) {
        return PromotionApiFp(this.configuration).getAudienceTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Promotion
     * @param {number} id
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    getPromotion(id, countryCode, options) {
        return PromotionApiFp(this.configuration).getPromotion(id, countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Promotion By Code
     * @param {string} promotionCode
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    getPromotionByCode(promotionCode, countryCode, options) {
        return PromotionApiFp(this.configuration).getPromotionByCode(promotionCode, countryCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Promotions matching filter criteria.
     * @param {string} [name] Optionally filter on promotion name contains value.
     * @param {number} [limit] Optionally limit number of results.
     * @param {number} [offset] Optionally skip number of results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    listPromotions(name, limit, offset, options) {
        return PromotionApiFp(this.configuration).listPromotions(name, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a SolrSearchResponse given various query parameters
     * @param {string} [searchQuery]
     * @param {string} [countryCode]
     * @param {number} [rows]
     * @param {number} [startRow]
     * @param {boolean} [activeOnly]
     * @param {Array<string>} [premiumProductNames]
     * @param {string} [productName]
     * @param {string} [subscriptionTerm]
     * @param {number} [acquisitionPrice]
     * @param {number} [campaignId]
     * @param {Array<'NewMember' | 'Retention' | 'Acquisition'>} [audienceTypes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    searchSolrOfferDocuments(searchQuery, countryCode, rows, startRow, activeOnly, premiumProductNames, productName, subscriptionTerm, acquisitionPrice, campaignId, audienceTypes, options) {
        return PromotionApiFp(this.configuration).searchSolrOfferDocuments(searchQuery, countryCode, rows, startRow, activeOnly, premiumProductNames, productName, subscriptionTerm, acquisitionPrice, campaignId, audienceTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Promotion V1 ** General use Update Promotion call, currently used by admin-ui **
     * @param {number} id
     * @param {FoolCommerceDtoUpdatePromotionForm} [foolCommerceDtoUpdatePromotionForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    updatePromotion(id, foolCommerceDtoUpdatePromotionForm, options) {
        return PromotionApiFp(this.configuration).updatePromotion(id, foolCommerceDtoUpdatePromotionForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Single Item Offer (Update Promotion Offer)
     * @param {number} promotionId
     * @param {number} offerId
     * @param {string} [countryCode]
     * @param {FoolCommerceDtoUpdateOfferForm} [foolCommerceDtoUpdateOfferForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    updateSingleItemOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options) {
        return PromotionApiFp(this.configuration).updateSingleItemOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update Subscription Offer (Update Promotion Offer)
     * @param {number} promotionId
     * @param {number} offerId
     * @param {string} [countryCode]
     * @param {FoolCommerceDtoUpdateOfferForm} [foolCommerceDtoUpdateOfferForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    updateSubscriptionOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options) {
        return PromotionApiFp(this.configuration).updateSubscriptionOffer(promotionId, offerId, countryCode, foolCommerceDtoUpdateOfferForm, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ProxyApi - axios parameter creator
 * @export
 */
export const ProxyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Let\'s do the Proxy!
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proxy: async (body, options = {}) => {
            const localVarPath = `/v1/proxy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ProxyApi - functional programming interface
 * @export
 */
export const ProxyApiFp = function (configuration) {
    const localVarAxiosParamCreator = ProxyApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Let\'s do the Proxy!
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proxy(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proxy(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ProxyApi - factory interface
 * @export
 */
export const ProxyApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ProxyApiFp(configuration);
    return {
        /**
         *
         * @summary Let\'s do the Proxy!
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proxy(body, options) {
            return localVarFp.proxy(body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProxyApi - object-oriented interface
 * @export
 * @class ProxyApi
 * @extends {BaseAPI}
 */
export class ProxyApi extends BaseAPI {
    /**
     *
     * @summary Let\'s do the Proxy!
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    proxy(body, options) {
        return ProxyApiFp(this.configuration).proxy(body, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * QuoteApi - axios parameter creator
 * @export
 */
export const QuoteApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns quote information for a user
         * @param {string} promotionCode Promotion code as GUID
         * @param {string} [countryCode] The country code ({\&quot;US\&quot;}) by default.
         * @param {number} [uid] User id
         * @param {boolean} [ignoreRedirect] If true, ignore any redirect set on this promo
         * @param {boolean} [ignoreInactive] If true and if the promo has passed its end date, show it anyway
         * @param {boolean} [performTaxLookup]
         * @param {string} [orderType]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromotionQuote: async (promotionCode, countryCode, uid, ignoreRedirect, ignoreInactive, performTaxLookup, orderType, accountId, options = {}) => {
            // verify required parameter 'promotionCode' is not null or undefined
            assertParamExists('getPromotionQuote', 'promotionCode', promotionCode);
            const localVarPath = `/v1/quotes/{promotionCode}`
                .replace(`{${"promotionCode"}}`, encodeURIComponent(String(promotionCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }
            if (ignoreRedirect !== undefined) {
                localVarQueryParameter['ignoreRedirect'] = ignoreRedirect;
            }
            if (ignoreInactive !== undefined) {
                localVarQueryParameter['ignoreInactive'] = ignoreInactive;
            }
            if (performTaxLookup !== undefined) {
                localVarQueryParameter['performTaxLookup'] = performTaxLookup;
            }
            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Promotion Quote for specific Tax Address
         * @param {FoolCommerceDtoAddressSpecificQuoteRequest} [foolCommerceDtoAddressSpecificQuoteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPromotionQuoteByTaxAddress: async (foolCommerceDtoAddressSpecificQuoteRequest, options = {}) => {
            const localVarPath = `/v1/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoAddressSpecificQuoteRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * QuoteApi - functional programming interface
 * @export
 */
export const QuoteApiFp = function (configuration) {
    const localVarAxiosParamCreator = QuoteApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Returns quote information for a user
         * @param {string} promotionCode Promotion code as GUID
         * @param {string} [countryCode] The country code ({\&quot;US\&quot;}) by default.
         * @param {number} [uid] User id
         * @param {boolean} [ignoreRedirect] If true, ignore any redirect set on this promo
         * @param {boolean} [ignoreInactive] If true and if the promo has passed its end date, show it anyway
         * @param {boolean} [performTaxLookup]
         * @param {string} [orderType]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromotionQuote(promotionCode, countryCode, uid, ignoreRedirect, ignoreInactive, performTaxLookup, orderType, accountId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromotionQuote(promotionCode, countryCode, uid, ignoreRedirect, ignoreInactive, performTaxLookup, orderType, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Promotion Quote for specific Tax Address
         * @param {FoolCommerceDtoAddressSpecificQuoteRequest} [foolCommerceDtoAddressSpecificQuoteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestPromotionQuoteByTaxAddress(foolCommerceDtoAddressSpecificQuoteRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestPromotionQuoteByTaxAddress(foolCommerceDtoAddressSpecificQuoteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * QuoteApi - factory interface
 * @export
 */
export const QuoteApiFactory = function (configuration, basePath, axios) {
    const localVarFp = QuoteApiFp(configuration);
    return {
        /**
         *
         * @summary Returns quote information for a user
         * @param {string} promotionCode Promotion code as GUID
         * @param {string} [countryCode] The country code ({\&quot;US\&quot;}) by default.
         * @param {number} [uid] User id
         * @param {boolean} [ignoreRedirect] If true, ignore any redirect set on this promo
         * @param {boolean} [ignoreInactive] If true and if the promo has passed its end date, show it anyway
         * @param {boolean} [performTaxLookup]
         * @param {string} [orderType]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromotionQuote(promotionCode, countryCode, uid, ignoreRedirect, ignoreInactive, performTaxLookup, orderType, accountId, options) {
            return localVarFp.getPromotionQuote(promotionCode, countryCode, uid, ignoreRedirect, ignoreInactive, performTaxLookup, orderType, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Promotion Quote for specific Tax Address
         * @param {FoolCommerceDtoAddressSpecificQuoteRequest} [foolCommerceDtoAddressSpecificQuoteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPromotionQuoteByTaxAddress(foolCommerceDtoAddressSpecificQuoteRequest, options) {
            return localVarFp.requestPromotionQuoteByTaxAddress(foolCommerceDtoAddressSpecificQuoteRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * QuoteApi - object-oriented interface
 * @export
 * @class QuoteApi
 * @extends {BaseAPI}
 */
export class QuoteApi extends BaseAPI {
    /**
     *
     * @summary Returns quote information for a user
     * @param {string} promotionCode Promotion code as GUID
     * @param {string} [countryCode] The country code ({\&quot;US\&quot;}) by default.
     * @param {number} [uid] User id
     * @param {boolean} [ignoreRedirect] If true, ignore any redirect set on this promo
     * @param {boolean} [ignoreInactive] If true and if the promo has passed its end date, show it anyway
     * @param {boolean} [performTaxLookup]
     * @param {string} [orderType]
     * @param {string} [accountId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    getPromotionQuote(promotionCode, countryCode, uid, ignoreRedirect, ignoreInactive, performTaxLookup, orderType, accountId, options) {
        return QuoteApiFp(this.configuration).getPromotionQuote(promotionCode, countryCode, uid, ignoreRedirect, ignoreInactive, performTaxLookup, orderType, accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Promotion Quote for specific Tax Address
     * @param {FoolCommerceDtoAddressSpecificQuoteRequest} [foolCommerceDtoAddressSpecificQuoteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    requestPromotionQuoteByTaxAddress(foolCommerceDtoAddressSpecificQuoteRequest, options) {
        return QuoteApiFp(this.configuration).requestPromotionQuoteByTaxAddress(foolCommerceDtoAddressSpecificQuoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * RefundApi - axios parameter creator
 * @export
 */
export const RefundApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Refund Single Item V1 ** Please use Refund Single Item V2 **
         * @param {FoolCommerceDtoSingleItemRefundForm} [foolCommerceDtoSingleItemRefundForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundSingleItem: async (foolCommerceDtoSingleItemRefundForm, options = {}) => {
            const localVarPath = `/v1/refunds/single-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoSingleItemRefundForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Refund Subscription Period V1 ** Please use Refund Subscription Period V2 **
         * @param {FoolCommerceDtoSubscriptionPeriodRefundForm} [foolCommerceDtoSubscriptionPeriodRefundForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundSubscriptionPeriod: async (foolCommerceDtoSubscriptionPeriodRefundForm, options = {}) => {
            const localVarPath = `/v1/refunds/subscription-periods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoSubscriptionPeriodRefundForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Rolls back and Refunds an Upgraded Subscription
         * @param {FoolCommerceDtoSubscriptionTransferRollbackForm} [foolCommerceDtoSubscriptionTransferRollbackForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackAndRefundSubscriptionUpgrade: async (foolCommerceDtoSubscriptionTransferRollbackForm, options = {}) => {
            const localVarPath = `/v1/refunds/subscription-rollback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoSubscriptionTransferRollbackForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * RefundApi - functional programming interface
 * @export
 */
export const RefundApiFp = function (configuration) {
    const localVarAxiosParamCreator = RefundApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Refund Single Item V1 ** Please use Refund Single Item V2 **
         * @param {FoolCommerceDtoSingleItemRefundForm} [foolCommerceDtoSingleItemRefundForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundSingleItem(foolCommerceDtoSingleItemRefundForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundSingleItem(foolCommerceDtoSingleItemRefundForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Refund Subscription Period V1 ** Please use Refund Subscription Period V2 **
         * @param {FoolCommerceDtoSubscriptionPeriodRefundForm} [foolCommerceDtoSubscriptionPeriodRefundForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundSubscriptionPeriod(foolCommerceDtoSubscriptionPeriodRefundForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundSubscriptionPeriod(foolCommerceDtoSubscriptionPeriodRefundForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Rolls back and Refunds an Upgraded Subscription
         * @param {FoolCommerceDtoSubscriptionTransferRollbackForm} [foolCommerceDtoSubscriptionTransferRollbackForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollbackAndRefundSubscriptionUpgrade(foolCommerceDtoSubscriptionTransferRollbackForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rollbackAndRefundSubscriptionUpgrade(foolCommerceDtoSubscriptionTransferRollbackForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * RefundApi - factory interface
 * @export
 */
export const RefundApiFactory = function (configuration, basePath, axios) {
    const localVarFp = RefundApiFp(configuration);
    return {
        /**
         *
         * @summary Refund Single Item V1 ** Please use Refund Single Item V2 **
         * @param {FoolCommerceDtoSingleItemRefundForm} [foolCommerceDtoSingleItemRefundForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundSingleItem(foolCommerceDtoSingleItemRefundForm, options) {
            return localVarFp.refundSingleItem(foolCommerceDtoSingleItemRefundForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Refund Subscription Period V1 ** Please use Refund Subscription Period V2 **
         * @param {FoolCommerceDtoSubscriptionPeriodRefundForm} [foolCommerceDtoSubscriptionPeriodRefundForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundSubscriptionPeriod(foolCommerceDtoSubscriptionPeriodRefundForm, options) {
            return localVarFp.refundSubscriptionPeriod(foolCommerceDtoSubscriptionPeriodRefundForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Rolls back and Refunds an Upgraded Subscription
         * @param {FoolCommerceDtoSubscriptionTransferRollbackForm} [foolCommerceDtoSubscriptionTransferRollbackForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackAndRefundSubscriptionUpgrade(foolCommerceDtoSubscriptionTransferRollbackForm, options) {
            return localVarFp.rollbackAndRefundSubscriptionUpgrade(foolCommerceDtoSubscriptionTransferRollbackForm, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RefundApi - object-oriented interface
 * @export
 * @class RefundApi
 * @extends {BaseAPI}
 */
export class RefundApi extends BaseAPI {
    /**
     *
     * @summary Refund Single Item V1 ** Please use Refund Single Item V2 **
     * @param {FoolCommerceDtoSingleItemRefundForm} [foolCommerceDtoSingleItemRefundForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    refundSingleItem(foolCommerceDtoSingleItemRefundForm, options) {
        return RefundApiFp(this.configuration).refundSingleItem(foolCommerceDtoSingleItemRefundForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Refund Subscription Period V1 ** Please use Refund Subscription Period V2 **
     * @param {FoolCommerceDtoSubscriptionPeriodRefundForm} [foolCommerceDtoSubscriptionPeriodRefundForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    refundSubscriptionPeriod(foolCommerceDtoSubscriptionPeriodRefundForm, options) {
        return RefundApiFp(this.configuration).refundSubscriptionPeriod(foolCommerceDtoSubscriptionPeriodRefundForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Rolls back and Refunds an Upgraded Subscription
     * @param {FoolCommerceDtoSubscriptionTransferRollbackForm} [foolCommerceDtoSubscriptionTransferRollbackForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    rollbackAndRefundSubscriptionUpgrade(foolCommerceDtoSubscriptionTransferRollbackForm, options) {
        return RefundApiFp(this.configuration).rollbackAndRefundSubscriptionUpgrade(foolCommerceDtoSubscriptionTransferRollbackForm, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SingleItemApi - axios parameter creator
 * @export
 */
export const SingleItemApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Cancel single item given its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSingleItem: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelSingleItem', 'id', id);
            const localVarPath = `/v1/single-items/cancel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get single item by its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleItem: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleItem', 'id', id);
            const localVarPath = `/v1/single-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SingleItemApi - functional programming interface
 * @export
 */
export const SingleItemApiFp = function (configuration) {
    const localVarAxiosParamCreator = SingleItemApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Cancel single item given its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSingleItem(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSingleItem(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get single item by its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleItem(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleItem(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * SingleItemApi - factory interface
 * @export
 */
export const SingleItemApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SingleItemApiFp(configuration);
    return {
        /**
         *
         * @summary Cancel single item given its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSingleItem(id, options) {
            return localVarFp.cancelSingleItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get single item by its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleItem(id, options) {
            return localVarFp.getSingleItem(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SingleItemApi - object-oriented interface
 * @export
 * @class SingleItemApi
 * @extends {BaseAPI}
 */
export class SingleItemApi extends BaseAPI {
    /**
     *
     * @summary Cancel single item given its ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleItemApi
     */
    cancelSingleItem(id, options) {
        return SingleItemApiFp(this.configuration).cancelSingleItem(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get single item by its ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleItemApi
     */
    getSingleItem(id, options) {
        return SingleItemApiFp(this.configuration).getSingleItem(id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Expire with optional date specified, if specified, must be on or before last active period. Defaults to  expiration date of last active period.
         * @param {number} [subscriptionId] id of the subscription to expire
         * @param {string} [lastActiveDateTime] date to expire the subscription on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireSubscription: async (subscriptionId, lastActiveDateTime, options = {}) => {
            const localVarPath = `/v1/subscriptions/expire-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }
            if (lastActiveDateTime !== undefined) {
                localVarQueryParameter['lastActiveDateTime'] = (lastActiveDateTime instanceof Date) ?
                    lastActiveDateTime.toISOString() :
                    lastActiveDateTime;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get subscription by its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscription', 'id', id);
            const localVarPath = `/v1/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} subscriptionPeriodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPeriodReceipt: async (subscriptionPeriodId, options = {}) => {
            // verify required parameter 'subscriptionPeriodId' is not null or undefined
            assertParamExists('getSubscriptionPeriodReceipt', 'subscriptionPeriodId', subscriptionPeriodId);
            const localVarPath = `/v1/subscriptions/periods/{subscriptionPeriodId}/receipt`
                .replace(`{${"subscriptionPeriodId"}}`, encodeURIComponent(String(subscriptionPeriodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get subscription transaction by subscription ID
         * @param {number} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTransaction: async (subscriptionId, options = {}) => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getSubscriptionTransaction', 'subscriptionId', subscriptionId);
            const localVarPath = `/v1/subscriptions/transactions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a quote for subscription rollback
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTransferRollbackQuote: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionTransferRollbackQuote', 'id', id);
            const localVarPath = `/v1/subscriptions/{id}/rollback`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Provides a list of subscription id\'s ready for renewal and user id\'s to update the credit card info.  This allows for end-to-end testing by updating the credit card for the subscription.
         * @param {number} [numberNeeded] the number you need for immediate testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionIdsForCreditCardTesting: async (numberNeeded, options = {}) => {
            const localVarPath = `/v1/subscriptions/user-subscriptions-for-testing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (numberNeeded !== undefined) {
                localVarQueryParameter['numberNeeded'] = numberNeeded;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Turn off autorebill for all subscriptions for a set of UIDs
         * @param {number} [adminUid]
         * @param {Array<number>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        turnOffAutoRebillForMembers: async (adminUid, requestBody, options = {}) => {
            const localVarPath = `/v1/subscriptions/turn-off-auto-rebill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (adminUid !== undefined) {
                localVarQueryParameter['adminUid'] = adminUid;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function (configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Expire with optional date specified, if specified, must be on or before last active period. Defaults to  expiration date of last active period.
         * @param {number} [subscriptionId] id of the subscription to expire
         * @param {string} [lastActiveDateTime] date to expire the subscription on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expireSubscription(subscriptionId, lastActiveDateTime, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expireSubscription(subscriptionId, lastActiveDateTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get subscription by its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} subscriptionPeriodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionPeriodReceipt(subscriptionPeriodId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionPeriodReceipt(subscriptionPeriodId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get subscription transaction by subscription ID
         * @param {number} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionTransaction(subscriptionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionTransaction(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a quote for subscription rollback
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionTransferRollbackQuote(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionTransferRollbackQuote(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Provides a list of subscription id\'s ready for renewal and user id\'s to update the credit card info.  This allows for end-to-end testing by updating the credit card for the subscription.
         * @param {number} [numberNeeded] the number you need for immediate testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionIdsForCreditCardTesting(numberNeeded, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionIdsForCreditCardTesting(numberNeeded, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Turn off autorebill for all subscriptions for a set of UIDs
         * @param {number} [adminUid]
         * @param {Array<number>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async turnOffAutoRebillForMembers(adminUid, requestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.turnOffAutoRebillForMembers(adminUid, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SubscriptionApiFp(configuration);
    return {
        /**
         *
         * @summary Expire with optional date specified, if specified, must be on or before last active period. Defaults to  expiration date of last active period.
         * @param {number} [subscriptionId] id of the subscription to expire
         * @param {string} [lastActiveDateTime] date to expire the subscription on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireSubscription(subscriptionId, lastActiveDateTime, options) {
            return localVarFp.expireSubscription(subscriptionId, lastActiveDateTime, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get subscription by its ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(id, options) {
            return localVarFp.getSubscription(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} subscriptionPeriodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPeriodReceipt(subscriptionPeriodId, options) {
            return localVarFp.getSubscriptionPeriodReceipt(subscriptionPeriodId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get subscription transaction by subscription ID
         * @param {number} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTransaction(subscriptionId, options) {
            return localVarFp.getSubscriptionTransaction(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a quote for subscription rollback
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTransferRollbackQuote(id, options) {
            return localVarFp.getSubscriptionTransferRollbackQuote(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Provides a list of subscription id\'s ready for renewal and user id\'s to update the credit card info.  This allows for end-to-end testing by updating the credit card for the subscription.
         * @param {number} [numberNeeded] the number you need for immediate testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionIdsForCreditCardTesting(numberNeeded, options) {
            return localVarFp.listSubscriptionIdsForCreditCardTesting(numberNeeded, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Turn off autorebill for all subscriptions for a set of UIDs
         * @param {number} [adminUid]
         * @param {Array<number>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        turnOffAutoRebillForMembers(adminUid, requestBody, options) {
            return localVarFp.turnOffAutoRebillForMembers(adminUid, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     *
     * @summary Expire with optional date specified, if specified, must be on or before last active period. Defaults to  expiration date of last active period.
     * @param {number} [subscriptionId] id of the subscription to expire
     * @param {string} [lastActiveDateTime] date to expire the subscription on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    expireSubscription(subscriptionId, lastActiveDateTime, options) {
        return SubscriptionApiFp(this.configuration).expireSubscription(subscriptionId, lastActiveDateTime, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get subscription by its ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscription(id, options) {
        return SubscriptionApiFp(this.configuration).getSubscription(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} subscriptionPeriodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscriptionPeriodReceipt(subscriptionPeriodId, options) {
        return SubscriptionApiFp(this.configuration).getSubscriptionPeriodReceipt(subscriptionPeriodId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get subscription transaction by subscription ID
     * @param {number} subscriptionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscriptionTransaction(subscriptionId, options) {
        return SubscriptionApiFp(this.configuration).getSubscriptionTransaction(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a quote for subscription rollback
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscriptionTransferRollbackQuote(id, options) {
        return SubscriptionApiFp(this.configuration).getSubscriptionTransferRollbackQuote(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Provides a list of subscription id\'s ready for renewal and user id\'s to update the credit card info.  This allows for end-to-end testing by updating the credit card for the subscription.
     * @param {number} [numberNeeded] the number you need for immediate testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    listSubscriptionIdsForCreditCardTesting(numberNeeded, options) {
        return SubscriptionApiFp(this.configuration).listSubscriptionIdsForCreditCardTesting(numberNeeded, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Turn off autorebill for all subscriptions for a set of UIDs
     * @param {number} [adminUid]
     * @param {Array<number>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    turnOffAutoRebillForMembers(adminUid, requestBody, options) {
        return SubscriptionApiFp(this.configuration).turnOffAutoRebillForMembers(adminUid, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TimePeriodApi - axios parameter creator
 * @export
 */
export const TimePeriodApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Money Back Guarantee Time Periods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMoneyBackGuaranteeTimePeriods: async (options = {}) => {
            const localVarPath = `/v1/timeperiods/moneybackguarantee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a TimePeriod matching the given parameters or create one and return it.
         * @param {FoolCommerceDtoTimePeriodForm} [foolCommerceDtoTimePeriodForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateTimePeriod: async (foolCommerceDtoTimePeriodForm, options = {}) => {
            const localVarPath = `/v1/timeperiods/get-or-create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(foolCommerceDtoTimePeriodForm, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Trial Time Periods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialTimePeriods: async (options = {}) => {
            const localVarPath = `/v1/timeperiods/trial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TimePeriodApi - functional programming interface
 * @export
 */
export const TimePeriodApiFp = function (configuration) {
    const localVarAxiosParamCreator = TimePeriodApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get Money Back Guarantee Time Periods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMoneyBackGuaranteeTimePeriods(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMoneyBackGuaranteeTimePeriods(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a TimePeriod matching the given parameters or create one and return it.
         * @param {FoolCommerceDtoTimePeriodForm} [foolCommerceDtoTimePeriodForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrCreateTimePeriod(foolCommerceDtoTimePeriodForm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrCreateTimePeriod(foolCommerceDtoTimePeriodForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Trial Time Periods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrialTimePeriods(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrialTimePeriods(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TimePeriodApi - factory interface
 * @export
 */
export const TimePeriodApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TimePeriodApiFp(configuration);
    return {
        /**
         *
         * @summary Get Money Back Guarantee Time Periods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMoneyBackGuaranteeTimePeriods(options) {
            return localVarFp.getMoneyBackGuaranteeTimePeriods(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a TimePeriod matching the given parameters or create one and return it.
         * @param {FoolCommerceDtoTimePeriodForm} [foolCommerceDtoTimePeriodForm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateTimePeriod(foolCommerceDtoTimePeriodForm, options) {
            return localVarFp.getOrCreateTimePeriod(foolCommerceDtoTimePeriodForm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Trial Time Periods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialTimePeriods(options) {
            return localVarFp.getTrialTimePeriods(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TimePeriodApi - object-oriented interface
 * @export
 * @class TimePeriodApi
 * @extends {BaseAPI}
 */
export class TimePeriodApi extends BaseAPI {
    /**
     *
     * @summary Get Money Back Guarantee Time Periods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimePeriodApi
     */
    getMoneyBackGuaranteeTimePeriods(options) {
        return TimePeriodApiFp(this.configuration).getMoneyBackGuaranteeTimePeriods(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a TimePeriod matching the given parameters or create one and return it.
     * @param {FoolCommerceDtoTimePeriodForm} [foolCommerceDtoTimePeriodForm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimePeriodApi
     */
    getOrCreateTimePeriod(foolCommerceDtoTimePeriodForm, options) {
        return TimePeriodApiFp(this.configuration).getOrCreateTimePeriod(foolCommerceDtoTimePeriodForm, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Trial Time Periods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimePeriodApi
     */
    getTrialTimePeriods(options) {
        return TimePeriodApiFp(this.configuration).getTrialTimePeriods(options).then((request) => request(this.axios, this.basePath));
    }
}
//# sourceMappingURL=api.js.map